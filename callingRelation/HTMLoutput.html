<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>running_log</title>
<!--
<link href='http://fonts.googleapis.com/css?family=Open+Sans:400italic,700italic,700,400&subset=latin,latin-ext' rel='stylesheet' type='text/css'>
<script type="text/javascript" src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
-->
<link rel="stylesheet" type="text/css" href="typora.css">
<link rel="stylesheet" type="text/css" href="CSSoutput.css">
<script src="jquery-1.6.2.min.js"></script>

<script type="text/javascript" src=JSoutput.js></script>

</head>
<body class='typora-export' ><h1 align="center">Decoding TNR</h1><ul><li><p class="testfold">Any part with light green background can be clicked to fold/unfold its underlying contents</p><div class="testunfold">A hidden paragraph.</div></li><li><p>Any <strong>function_name</strong> is displayed in bold font</p></li><li><p>Any <em>new_variable</em> in the codes is displayed in italic font</p></li><li><p>The <iptt>important contents</iptt> will be highlighted.</p></li><li><p>The <log>example result of a test run</log> of the program has blue font. </p></li></ul>
======================================================================
<br/><div class="fold">Running scaldimer.py with the following parameters:</div><br/><div class="unfold">A_chis = None<br/>A_eps = 1e-11<br/>H = 0j<br/>J = (1+0j)<br/>algorithm = TNR<br/>beta = 0.44068679351<br/>block_width = 4<br/>chis_tnr = [6]<br/>chis_trg = [10]<br/>defect_angles = [0]<br/>do_coarse_momenta = True<br/>do_dual = False<br/>do_eigenvectors = False<br/>do_momenta = True<br/>draw_defect_angle = True<br/>draw_exact_circles = True<br/>draw_exact_lines = True<br/>dtype = <class 'numpy.complex128'><br/>fix_gauges = True<br/>horz_refl = True<br/>initial2x2 = False<br/>initial4x4 = True<br/>iter_count = 5<br/>max_dim_plot = 4.5<br/>model = ising<br/>n_dims_do = 30<br/>n_dims_plot = 30<br/>n_discard = 0<br/>opt_eps_chi = 1e-08<br/>opt_eps_conv = 1e-11<br/>opt_iters_tens = 1<br/>opt_max_iter = 10000<br/>plot_by_alpha = False<br/>plot_by_momenta = True<br/>plot_by_qnum = False<br/>print_errors = 2<br/>qnums_do = []<br/>qnums_plot = []<br/>return_gauges = True<br/>return_pieces = True<br/>reuse_initial = True<br/>save_fit_plot = False<br/>save_plots = False<br/>save_scaldim_file = True<br/>show_plots = True<br/>sixvertex_a = 1<br/>sixvertex_b = 1<br/>sixvertex_c = 1.41421356237<br/>symmetry_tensors = True<br/>xtick_rotation = 0<br/></div><p> When tensors are represented diagramatically, the numbering of indices
 is thought to run clock-wise, starting from 9 o'clock. If several
 indices are pointing in the same direction the order within them is
 bottom-up and left to right. This of course makes no mathematical
 difference, but may help with reading the code. This ordering may not
 always hold inside functions between intermediate steps (hopefully I
 have commented on all such exceptions), but is used at least when
 returning values.</p><div class="fold">A single TNR step.</div><div class="unfold">
    <ul>
    <li>Parameters:
    <ul>
    <li>- <em>A_list</em> is a list of 2 tensors that form the block which is to be
      coarse-grained. It can also be a single tensor, in which case 2
      copies of it are used. The block to be coarse-grained is formed
      like this:
      <p><img src="tnr1.png" /></p>
      ^dg (dagger) denotes up-down transposing and complex conjugating.</li>
    <li>- <em>chis_tnr</em> is either an integer or an iterable of integers. These
      are the bond dimensions for truncation in the first (TNR) step of
      algorithm.  The smallest one of them (assuming there are several)
      is used such that the truncation error is smaller than
      <em>ops_eps_chi</em>.</li>
    <li>- <em>chis_trg</em> is the same as <em>chis_tnr</em>, but for the second (TRG-like)
      step of the algorithm.</li>
    <li>- <em>horz_refl</em> specifies whether we can assume reflection symmetry in
      the horizontal direction in the following sense: If <em>horz_refl</em> ==
      True, then the element A_list[1] is ignored and in stead is assumed to
      be the conjugate of A_list[0], where conjugation here means
      left-right reflection and complex conjugation. This also
      guarantees that the resulting <em>A_new</em> is left-right reflection +
      complex conjugation symmetric up to gauge factors. Defaults to
      False. See also <em>G_hh</em> and <em>return_gauges</em>.</li>
    <li>- <em>G_hh</em> is one of the gauge matrices of the given A. See
      return_gauges for explanations of what the gauge matrices are.
      G_hh is only needed if <em>horz_refl</em>==True, and the other gauge
      matrices are not needed at all for tnr_step. Defaults to the
      identity matrix.</li>
    <li>- <em>opt_eps_chi</em> is the limit for the truncation error when choosing
      the dimension to truncate to. For details see <em>chis_tnr</em> and
      <em>chis_trg</em>. Defaults to None, in which case the largest allowed bond
      dimension is always used.</li>
    <li>- <em>opt_iters_tens</em> is the number of iterations done when optimizing a
      single tensor, before moving on to the next tensor. This is only
      relevant for optimizations where the cost function is linearized
      and a single iteration does not result in the optimal solution for
      the given (non-linearized) environment. Defaults to 1.</li>
    <li>- <em>opt_eps_conv</em> (conv for convergence) is the limit below which the
      change in the cost function for successive iterations of the
      optimization algorithm must fall for the loop to finish. Defaults
      to 1e-9.</li>
    <li>- <em>opt_max_iter</em> is the maximum number of iterations done in the
      optimization of the tensors for every chi. This is only relevant
      if convergence is never reached as in the case <em>ops_eps_conv</em> = 0.
      Defaults to np.inf.</li>
    <li>- <em>A_eps</em> is the maximum allowed truncation error when SVDing the
      tensors in A_list. This SVD is done simply to boost performance,
      and the error at this step should be kept small.  Defaults to 0.</li>
    <li>- <em>A_chis</em> is the possible truncation dimensions when SVDing A, see
      A_eps. Defaults to None which is interpreted as "use any dimension
      necessary", then <iptt><em>A_chis</em> is determined by <em>A_eps</em></iptt>, <em>A_chis</em>
       decreases as <em>A_eps</em> increases. </li>
    <li>- <em>fix_gauges</em> determines whether to fix the gauge freedom of SVD when
      building z and splitting B to be the same as at the previous step.
      If <em>fix_gauges</em>==True, pieces needs to be given. Defaults to False.</li>
    <li>- <em>log_fact</em> is the logarithm of the factor by which the original A
      should be multiplied to get the physical tensor. Defaults to 0.</li>
    <li>- The higher the print_errors number is, the more intermediate steps
      will produce text output that tells about the progression of the
      algorithm and the errors induced in the coarse-graning. Note that
      asking for more error output induces non-trivial computations that
      slow down the function.</li>
    <li>- <em>return_pieces</em> determines whether the tensors used in building up
      the coarse-grained <em>A_new</em> (<em>u,v_L,v_R,w,BUS,BSV</em>) are also returned. Defaults to False.</li>
    <li>- <em>return_gauges</em> determines whether to also return the gauge matrices
      related to different conjugate transposes of the final tensor.  If
      <em>return_gauges</em> = True then the last value returned is the tuple
      (<em>G_hh</em>, <em>G_hv</em>, <em>G_vh</em>), where the different Gs are matrices such that

      <p><img src="tnr2.png" /></p>
      Here ^* denotes complex conjugation and the bending of the legs
      denotes different transposes. Here <em>G_hh</em> is a diagonal matrix of
      +/-1, and the others are unitary.  The logic in the naming of the
      gauge matrices is that h refers to horizontal and v refers to
      vertical and the first letter in the subscript tells which
      transpose of A_new this matrix is related to and the second one
      tells which legs (horizontal or vertical) of <em>A_new</em> this matrix
      should be attached to.</li>
      </ul>
      </li>
      <li>
    Returns: <em>A_new</em>, <em>new_log_fact</em>, <em>pieces</em>, (<em>G_hh, G_hv, G_vh</em>),
    with the last two being opitional.
    <ul>
    <li>- <strong>tnr_step</strong> returns the coarse-grained tensor <em>A_new</em> and the logarithm
      <em>new_log_fact</em> of the related factor such that A_new *
      exp(new_log_fact) is the physical tensor.</li>
    <li>- If <em>return_pieces==True</em> then a third value is also returned that is
      a dictionary of the tensors <em>A_part_list, u, v, w, B, BUS, BSV</em> and
      <em>z</em>, with these names as string keys.</li>
    <li>- If <em>return_gauges==True</em> then the gauge matrices G_hh, G_hv and G_vh
      that map A_new to its various conjugates are also returned as a
      dict with the above names as string keys.</li>
      </ul>
      </li>
      </ul>
    </div><br/><br/> <em>do_coarse_momenta</em> is false, get <em>res_fine</em> from <strong>load_cft_data</strong><blockquote><p class="foldda1b6ff6-64b0-11e7-9e29-a820660f017d">Beginning of <strong>load_cft_data</strong>:</p><div class="unfoldda1b6ff6-64b0-11e7-9e29-a820660f017d"><blockquote><p class="foldda1fcbbe-64b0-11e7-aa7f-a820660f017d">Beginning of <strong>get_cft_data</strong>:</p><div class="unfoldda1fcbbe-64b0-11e7-aa7f-a820660f017d"><blockquote><p class="foldda1fce52-64b0-11e7-89b9-a820660f017d">Beginning of <strong>get_T</strong>:</p><div class="unfoldda1fce52-64b0-11e7-89b9-a820660f017d"><blockquote><p class="foldda1fd06e-64b0-11e7-8327-a820660f017d">Beginning of <strong>get_normalized_tensor</strong>:</p><div class="unfoldda1fd06e-64b0-11e7-8327-a820660f017d"><blockquote><p class="foldda1fd212-64b0-11e7-8aa4-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfoldda1fd212-64b0-11e7-8aa4-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="foldda1fd424-64b0-11e7-9ff3-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfoldda1fd424-64b0-11e7-9ff3-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote><blockquote><p class="foldda1fdcee-64b0-11e7-a2eb-a820660f017d">Beginning of <strong>generate_normalized_tensor</strong>:</p><div class="unfoldda1fdcee-64b0-11e7-a2eb-a820660f017d">Generating the normalized, coarse-grained tensor with the following parameters:<br/>A_chis = None; A_eps = 1e-11; H = 0j; J = (1+0j); algorithm = TNR; beta = 0.44068679351; block_width = 4; chis_tnr = [6]; chis_trg = [10]; defect_angles = [0]; do_coarse_momenta = False; do_dual = False; do_eigenvectors = False; do_momenta = True; draw_defect_angle = True; draw_exact_circles = True; draw_exact_lines = True; dtype = <class 'numpy.complex128'>; fix_gauges = True; horz_refl = True; initial2x2 = False; initial4x4 = True; iter_count = 5; max_dim_plot = 4.5; model = ising; n_dims_do = 30; n_dims_plot = 30; n_discard = 0; opt_eps_chi = 1e-08; opt_eps_conv = 1e-11; opt_iters_tens = 1; opt_max_iter = 10000; plot_by_alpha = False; plot_by_momenta = True; plot_by_qnum = False; print_errors = 2; qnums_do = []; qnums_plot = []; return_gauges = True; return_pieces = True; reuse_initial = True; save_errors = False; save_fit_plot = False; save_plots = False; save_scaldim_file = True; show_plots = True; sixvertex_a = 1; sixvertex_b = 1; sixvertex_c = 1.41421356237; symmetry_tensors = True; xtick_rotation = 0; <blockquote><p class="foldda200d36-64b0-11e7-83d3-a820660f017d">Beginning of <strong>the for loop of iter_count</strong>:</p><div class="unfoldda200d36-64b0-11e7-83d3-a820660f017d"><blockquote><p class="foldda2010f6-64b0-11e7-887d-a820660f017d">Beginning of <strong>get_tensor</strong>:</p><div class="unfoldda2010f6-64b0-11e7-887d-a820660f017d"><blockquote><p class="foldda20149a-64b0-11e7-a917-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfoldda20149a-64b0-11e7-a917-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="foldda202776-64b0-11e7-a09c-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfoldda202776-64b0-11e7-a09c-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote><blockquote><p class="foldda202d6e-64b0-11e7-a6f7-a820660f017d">Beginning of <strong>generate_tensor</strong>:</p><div class="unfoldda202d6e-64b0-11e7-a6f7-a820660f017d"><blockquote><p class="foldda202ee4-64b0-11e7-ab6c-a820660f017d">Beginning of <strong>generate_first_tensor</strong>:</p><div class="unfoldda202ee4-64b0-11e7-ab6c-a820660f017d"><br/>generate the starting point tensor A^{(0)} by grouping some(2*2 or 4*4) initial tensors<br/><blockquote><p class="foldda203040-64b0-11e7-b9b4-a820660f017d">Beginning of <strong>get_initial_tensor</strong>:</p><div class="unfoldda203040-64b0-11e7-b9b4-a820660f017d">calculate the initial tensor A_ijkl using np.einsum module<blockquote><p class="foldda2031c6-64b0-11e7-a6bb-a820660f017d">Beginning of <strong>ising_hamiltonian</strong>:</p><div class="unfoldda2031c6-64b0-11e7-a6bb-a820660f017d"></div>End of <strong>ising_hamiltonian</strong></blockquote>generate the very initial tensor pre_A[0] with bond dimersion 2<br/><log>The shape of initial_tensor is:[[1, 1], [1, 1], [1, 1], [1, 1]]<br/></log></div>End of <strong>get_initial_tensor</strong></blockquote>initial4x4 is true, so the bond dimension chi^{(0)}=16=[8,8] in CDL notation.<br/><log>The shape of generated first tensor is:[[8, 8], [8, 8], [8, 8], [8, 8]]</log><br/>Also set the initial <em>log_fact</em> to be 0 in this step.<br/></div>End of <strong>generate_first_tensor</strong></blockquote></div>End of <strong>generate_tensor</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_tensor</strong></blockquote><blockquote><p class="foldda287502-64b0-11e7-8a56-a820660f017d">Beginning of <strong>get_tensor</strong>:</p><div class="unfoldda287502-64b0-11e7-8a56-a820660f017d"><blockquote><p class="foldda2878ca-64b0-11e7-9456-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfoldda2878ca-64b0-11e7-9456-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="foldda287ab6-64b0-11e7-ad4e-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfoldda287ab6-64b0-11e7-ad4e-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote><blockquote><p class="foldda2882ec-64b0-11e7-94ba-a820660f017d">Beginning of <strong>generate_tensor</strong>:</p><div class="unfoldda2882ec-64b0-11e7-94ba-a820660f017d"><blockquote><p class="foldda288418-64b0-11e7-a76e-a820660f017d">Beginning of <strong>generate_next_tensor</strong>:</p><div class="unfoldda288418-64b0-11e7-a76e-a820660f017d"><blockquote><p class="foldda28851c-64b0-11e7-a3dc-a820660f017d">Beginning of <strong>get_tensor</strong>:</p><div class="unfoldda28851c-64b0-11e7-a3dc-a820660f017d"><blockquote><p class="foldda288682-64b0-11e7-aee8-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfoldda288682-64b0-11e7-aee8-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="foldda28879a-64b0-11e7-a386-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfoldda28879a-64b0-11e7-a386-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote><blockquote><p class="foldda288b28-64b0-11e7-a4ae-a820660f017d">Beginning of <strong>generate_tensor</strong>:</p><div class="unfoldda288b28-64b0-11e7-a4ae-a820660f017d"><blockquote><p class="foldda288c36-64b0-11e7-9346-a820660f017d">Beginning of <strong>generate_first_tensor</strong>:</p><div class="unfoldda288c36-64b0-11e7-9346-a820660f017d"><br/>generate the starting point tensor A^{(0)} by grouping some(2*2 or 4*4) initial tensors<br/><blockquote><p class="foldda288d3a-64b0-11e7-a043-a820660f017d">Beginning of <strong>get_initial_tensor</strong>:</p><div class="unfoldda288d3a-64b0-11e7-a043-a820660f017d">calculate the initial tensor A_ijkl using np.einsum module<blockquote><p class="foldda288e48-64b0-11e7-9f1b-a820660f017d">Beginning of <strong>ising_hamiltonian</strong>:</p><div class="unfoldda288e48-64b0-11e7-9f1b-a820660f017d"></div>End of <strong>ising_hamiltonian</strong></blockquote>generate the very initial tensor pre_A[0] with bond dimersion 2<br/><log>The shape of initial_tensor is:[[1, 1], [1, 1], [1, 1], [1, 1]]<br/></log></div>End of <strong>get_initial_tensor</strong></blockquote>initial4x4 is true, so the bond dimension chi^{(0)}=16=[8,8] in CDL notation.<br/><log>The shape of generated first tensor is:[[8, 8], [8, 8], [8, 8], [8, 8]]</log><br/>Also set the initial <em>log_fact</em> to be 0 in this step.<br/></div>End of <strong>generate_first_tensor</strong></blockquote></div>End of <strong>generate_tensor</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_tensor</strong></blockquote> Coarse-graining, iter_count = #1: / <br/><blockquote><p class="foldda306598-64b0-11e7-ac81-a820660f017d">Beginning of <strong>get_gauges</strong>:</p><div class="unfoldda306598-64b0-11e7-ac81-a820660f017d"><blockquote><p class="foldda306992-64b0-11e7-a3df-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfoldda306992-64b0-11e7-a3df-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="foldda306b36-64b0-11e7-95c2-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfoldda306b36-64b0-11e7-95c2-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote><blockquote><p class="foldda3072f0-64b0-11e7-bf6b-a820660f017d">Beginning of <strong>generate_tensor</strong>:</p><div class="unfoldda3072f0-64b0-11e7-bf6b-a820660f017d"><blockquote><p class="foldda307482-64b0-11e7-a29a-a820660f017d">Beginning of <strong>generate_first_tensor</strong>:</p><div class="unfoldda307482-64b0-11e7-a29a-a820660f017d"><br/>generate the starting point tensor A^{(0)} by grouping some(2*2 or 4*4) initial tensors<br/><blockquote><p class="foldda3075b8-64b0-11e7-918e-a820660f017d">Beginning of <strong>get_initial_tensor</strong>:</p><div class="unfoldda3075b8-64b0-11e7-918e-a820660f017d">calculate the initial tensor A_ijkl using np.einsum module<blockquote><p class="foldda3076f6-64b0-11e7-b8e9-a820660f017d">Beginning of <strong>ising_hamiltonian</strong>:</p><div class="unfoldda3076f6-64b0-11e7-b8e9-a820660f017d"></div>End of <strong>ising_hamiltonian</strong></blockquote>generate the very initial tensor pre_A[0] with bond dimersion 2<br/><log>The shape of initial_tensor is:[[1, 1], [1, 1], [1, 1], [1, 1]]<br/></log></div>End of <strong>get_initial_tensor</strong></blockquote>initial4x4 is true, so the bond dimension chi^{(0)}=16=[8,8] in CDL notation.<br/><log>The shape of generated first tensor is:[[8, 8], [8, 8], [8, 8], [8, 8]]</log><br/>Also set the initial <em>log_fact</em> to be 0 in this step.<br/></div>End of <strong>generate_first_tensor</strong></blockquote></div>End of <strong>generate_tensor</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_gauges</strong></blockquote><blockquote><p class="foldda387f92-64b0-11e7-9e36-a820660f017d">Beginning of <strong>get_pieces</strong>:</p><div class="unfoldda387f92-64b0-11e7-9e36-a820660f017d"><blockquote><p class="foldda3883b6-64b0-11e7-bd46-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfoldda3883b6-64b0-11e7-bd46-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="foldda3885c8-64b0-11e7-b5ae-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfoldda3885c8-64b0-11e7-b5ae-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote><blockquote><p class="foldda388c30-64b0-11e7-bd1a-a820660f017d">Beginning of <strong>generate_tensor</strong>:</p><div class="unfoldda388c30-64b0-11e7-bd1a-a820660f017d"><blockquote><p class="foldda388d6e-64b0-11e7-b39f-a820660f017d">Beginning of <strong>generate_first_tensor</strong>:</p><div class="unfoldda388d6e-64b0-11e7-b39f-a820660f017d"><br/>generate the starting point tensor A^{(0)} by grouping some(2*2 or 4*4) initial tensors<br/><blockquote><p class="foldda388e88-64b0-11e7-b5c1-a820660f017d">Beginning of <strong>get_initial_tensor</strong>:</p><div class="unfoldda388e88-64b0-11e7-b5c1-a820660f017d">calculate the initial tensor A_ijkl using np.einsum module<blockquote><p class="foldda388fa8-64b0-11e7-85bc-a820660f017d">Beginning of <strong>ising_hamiltonian</strong>:</p><div class="unfoldda388fa8-64b0-11e7-85bc-a820660f017d"></div>End of <strong>ising_hamiltonian</strong></blockquote>generate the very initial tensor pre_A[0] with bond dimersion 2<br/><log>The shape of initial_tensor is:[[1, 1], [1, 1], [1, 1], [1, 1]]<br/></log></div>End of <strong>get_initial_tensor</strong></blockquote>initial4x4 is true, so the bond dimension chi^{(0)}=16=[8,8] in CDL notation.<br/><log>The shape of generated first tensor is:[[8, 8], [8, 8], [8, 8], [8, 8]]</log><br/>Also set the initial <em>log_fact</em> to be 0 in this step.<br/></div>End of <strong>generate_first_tensor</strong></blockquote></div>End of <strong>generate_tensor</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_pieces</strong></blockquote><blockquote><p class="foldda403162-64b0-11e7-b9ac-a820660f017d">Beginning of <strong>TNR_step</strong>:</p><div class="unfoldda403162-64b0-11e7-b9ac-a820660f017d">The function <strong>format_parameters</strong> formats some of the parameters given to <em>tnr_step</em> to a canonical form.<br/><ul>
    <li>Make sure <em>A_list</em> is a list of 2 tensors</li>
    <li>Create pars, gauges and pieces.</li>
    <li>Values are taken primarily from kwargs, then from pars, gauges and pieces, and finally from default. Only ones listed in defaults are used, others are ignored.</li>
    <li>Make sure <em>chis_tnr</em> and <em>chis_trg</em> are a lists of integers (or at least singlet lists of one integer) and sorted from small to large.</li>
    <li>If several chis to loop over are given but there is no epsilon to determine sufficient accuracy, then just use the largest chi.</li>
    </ul><blockquote><p class="foldda403874-64b0-11e7-a7d4-a820660f017d">Beginning of <strong>symmetrize_A_list</strong>:</p><div class="unfoldda403874-64b0-11e7-a7d4-a820660f017d"> Symmetrizes <em>A_list</em> according to the value of <em>horz_refl</em>. <br/><p class="param_use"><em>horz_relf</em> is true, transpose A[0] to get A[1]</p></div>End of <strong>symmetrize_A_list</strong></blockquote><blockquote><p class="foldda4049dc-64b0-11e7-9d8b-a820660f017d">Beginning of <strong>split_A_list</strong>:</p><div class="unfoldda4049dc-64b0-11e7-9d8b-a820660f017d"> SVDs the tensors in A_list and returns a list of lists with the parts in them. See split_A for details.<br/><blockquote><p class="foldda404f7e-64b0-11e7-95f6-a820660f017d">Beginning of <strong>split_A</strong>:</p><div class="unfoldda404f7e-64b0-11e7-95f6-a820660f017d"><log>Shape of A is[[8, 8], [8, 8], [8, 8], [8, 8]]</log><br/> <br/>Splits an A tensor by SVD into two. eps is the tolerance in the
    SVD, <em>chis</em> is the list of bond dimensions to try when splitting (by
    default the full possible range is tried) and direction specifies
    the way to split.  If direction == 'nesw' (case and space
    insensitive) the splitting is done so that the northeast and
    southwest components are created, and similarly for direction ==
    'nwse'. For all other values of direction both splittings are done.
    The values are returned in the order A_NW, A_SE, A_NE, A_SW,
    possibly leaving out some based on direction.<br/>
    <br/><log>Split A NWSE with chi=198</log><br/><log>split A in NWSE direction,bond dimensions are like:<br/>A_NW:[[8, 8], [8, 8], [99, 99]]<br/>A_SE:[[99, 99], [8, 8], [8, 8]]<br/></log>The final result of split_A is a list, of which the elements are like A_NW,..., and each element has three external legs.<br/></div>End of <strong>split_A</strong></blockquote><blockquote><p class="foldda4526f4-64b0-11e7-837e-a820660f017d">Beginning of <strong>split_A</strong>:</p><div class="unfoldda4526f4-64b0-11e7-837e-a820660f017d"><log>Shape of A is[[8, 8], [8, 8], [8, 8], [8, 8]]</log><br/> <br/>Splits an A tensor by SVD into two. eps is the tolerance in the
    SVD, <em>chis</em> is the list of bond dimensions to try when splitting (by
    default the full possible range is tried) and direction specifies
    the way to split.  If direction == 'nesw' (case and space
    insensitive) the splitting is done so that the northeast and
    southwest components are created, and similarly for direction ==
    'nwse'. For all other values of direction both splittings are done.
    The values are returned in the order A_NW, A_SE, A_NE, A_SW,
    possibly leaving out some based on direction.<br/>
    <log>Split A NESW with chi=198<br/>split A in NESW direction,bond dimensions are like:<br/>A_NE:[[8, 8], [8, 8], [99, 99]]<br/>A_SW:[[8, 8], [99, 99], [8, 8]]</log><br/>The final result of split_A is a list, of which the elements are like A_NW,..., and each element has three external legs.<br/></div>End of <strong>split_A</strong></blockquote>A_part_list = [split(A[0],nwse),split(A[1],nesw)]<br/>A_part_list[0]=split(A0,nwse)<br/>A_part_list[1]=split(A1,nesw)<br/>A_part_list[0][0]=A_NW<br/>A_part_list[0][1]=A_SE<br/>A_part_list[1][0]=A_NE<br/>A_part_list[1][1]=A_SW</div>End of <strong>split_A_list</strong></blockquote> store the result of <strong>split_A_list</strong> to <em>A_part_list</em><br/>
    A_part_list in only used in upb when pars[use_part] is true, otherwise this A_part_list is never used.<br>
     use SVDed A if chi_split < chi_orig**(3/2)<br/>calculate <em>chi_orig</em> and <em>chi_split</em> from <em>A_NW</em>,then determine whether to use the SVD of the original tensor, based on a rough estimate of whether it's computationally advantageous.<iptt>pars["use_parts"] = chi_split < chi_orig**(3/2)</iptt>Not using the SVDed A.<br/><br/>Obtain the optimized <em>u,v,w</em>.<br/><blockquote><p class="foldda49716e-64b0-11e7-b0c5-a820660f017d">Beginning of <strong>build_uvw</strong>:</p><div class="unfoldda49716e-64b0-11e7-b0c5-a820660f017d">This function optimize the u,v_R,v_L independently(linearly) as in the paper.<br/>Loop over growing truncation dimensions until the truncation error is small enough.<br/><br/> recall that chi_prime < chi^2, so the truncation dimension grows from chi to chi_prime after one TNR step<br/><blockquote><p class="foldda4bd542-64b0-11e7-b0db-a820660f017d">Beginning of <strong>for loop</strong>:</p><div class="unfoldda4bd542-64b0-11e7-b0db-a820660f017d"><pre>for <em>chi_num, chi</em> in enumerate(pars["chis_tnr"]):</pre><br/>loop over <em>chis_tnr</em> the bond dimension<br/><enumerate object at 0x107b4ef78><br/>Optimizing for chi = 6.<br/><blockquote><p class="foldda4bda54-64b0-11e7-82d5-a820660f017d">Beginning of <strong>initial_uvw</strong>:</p><div class="unfoldda4bda54-64b0-11e7-82d5-a820660f017d"> Returns the initial disentangler and isometries that are the starting point of the optimization. The initial u is the identity, the initial isometries are SVDed from A just like in TRG, truncated to dimension chi.<br/>the initial u is an identity tensor: u = scon((eye1, eye2), ([-1,-3], [-4,-2]))<br>the initial v_L and v_R are results from svd of A: w_dg = A_list[0].svd((0,1), (2,3), chis=chi)[0]<br/>v_dg = A_list[1].svd((0,3), (1,2), chis=chi)[2]<br/><log>initial u has shape: [[8, 8], [8, 8], [8, 8], [8, 8]]</log><br/><log>initial v has shape: [[8, 8], [3, 3], [8, 8]]</log><br/><log>initial w has shape: [[3, 3], [8, 8], [8, 8]]</log><br/></div>End of <strong>initial_uvw</strong></blockquote>there is <iptt>a while loop in this for loop</iptt> to optimize u,v,w<br/><pre>while (cost_change > pars["opt_eps_conv"] and counter < pars["opt_max_iter"]):
                counter += 1
                old_cost = new_cost
                v, w = <strong>optimize_isometries</strong>(u, v, w, A_list, A_part_list, pars, gauges)
                u, B_norm = <strong>optimize_disentangler</strong>(u, v, w, A_list, A_part_list, pars, return_B_norm=True)</pre><br/> keep optimizing u,v,w iteratively to <iptt>maximize the norm of B</iptt> until the relative change is less than <em>opt_eps_conv</em>. if convergence is not reached in <em>opt_max_iter</em> steps, stop and move on</div>End of <strong>for loop</strong></blockquote><log>Truncated bond dimension in TNR: 6</log><br/><log>Optimization converged after 1596 iterations.</log><br/><log>Relative error in optimized, truncated TNR block is: 3.245e-03 + 0j</log><br/><log>u has shape: [[8, 8], [8, 8], [8, 8], [8, 8]]</log><br/><log>v has shape: [[8, 8], [3, 3], [8, 8]]</log><br/><log>w has shape: [[3, 3], [8, 8], [8, 8]]</log><br/></div>End of <strong>build_uvw</strong></blockquote>Build the intermediate tensors <em>B</em> and <em>z</em> and use them to derive <em>A_new</em>.<br/><blockquote><p class="folde4ab113a-64b1-11e7-ba6f-a820660f017d">Beginning of <strong>build_B</strong>:</p><div class="unfolde4ab113a-64b1-11e7-ba6f-a820660f017d"></div>End of <strong>build_B</strong></blockquote>This step is very simple, since <em>upb</em> (the upper half of B) is totally determined by <em>u,v,w</em> and <em>A</em>, just contract <em>upb</em> with upb^dagger<br/><br/><log>before splitting B has shape: [[3, 3], [3, 3], [3, 3], [3, 3]]</log><br/><blockquote><p class="folde4b32a98-64b1-11e7-afe9-a820660f017d">Beginning of <strong>split_B</strong>:</p><div class="unfolde4b32a98-64b1-11e7-afe9-a820660f017d">no optimization in split_B, just take out the SVDed value<br/><log>The splitting result has shape:<br/>US (should be U*sqrt(S) ): [[3, 3], [5, 5], [3, 3]]<br/>SV (should be sqrt(S)*V ): [[5, 5], [3, 3], [3, 3]]<br/></log><log>Truncated bond dimension in split_B: 10</log><br/></div>End of <strong>split_B</strong></blockquote>split B horizontally, BUS,BSV = B.svd((0,3), (1,2))<br/>obtain <em>BUS, BSV</em> from <strong>split_B</strong>.<br/> <div class="codeblock">splitting B with chis=chis_trg</div><p class="param_use"><em>return_gauges</em> is true, then derive <em>G_hh</em> from <strong>split_B</strong></p><blockquote><p class="folde4b39410-64b1-11e7-8ff6-a820660f017d">Beginning of <strong>build_z</strong>:</p><div class="unfolde4b39410-64b1-11e7-8ff6-a820660f017d">also no optimization in build_z, calculate the environment <em>M</em> and SVD it.<br/><log>the environment of z has shape: [[8, 8], [8, 8], [8, 8], [8, 8]]</log><br/><log>z has shape: [[5, 5], [8, 8], [8, 8]]</log><br/><log>Truncated bond dimension in build_z: 10</log><br/></div>End of <strong>build_z</strong></blockquote>mapping from the parameters used here to that used in the paper'algorithms in TNR'
    <pre>
    u ---> u
    w ---> v_L
    v ---> v_R
    z ---> w
    </pre>
    <blockquote><p class="folde4b889ac-64b1-11e7-a820-a820660f017d">Beginning of <strong>build_A_new</strong>:</p><div class="unfolde4b889ac-64b1-11e7-a820-a820660f017d"><log><em>A_new</em> has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/></div>End of <strong>build_A_new</strong></blockquote>Scale A_new to have largest values around unity and use that to update new_log_fact.<br/>normalize <em>A_new</em> to have unit norm<br><iptt>new_log_fact = np.log(fact) + 4*log_fact</iptt>, here <em>fact</em> is the original norm of <em>A_new</em>, <em>log_fact is inherited from pars[...]</em><br/>Put A_new,new_log_fact to return value<br><p class="param_use">return_pieces is true, put A_part_list,u,v,w,B,BUS,BSV,z into return value</p><p class="param_use">return_gauges & horz_refl true, then optimize_G_hv</p><blockquote><p class="folde4ba251e-64b1-11e7-a7ef-a820660f017d">Beginning of <strong>optimize_G_hv</strong>:</p><div class="unfolde4ba251e-64b1-11e7-a7ef-a820660f017d"><blockquote><p class="folde4baa840-64b1-11e7-a5b1-a820660f017d">Beginning of <strong>while loop under cost_change > 1e-11 and counter < 10000</strong>:</p><div class="unfolde4baa840-64b1-11e7-a5b1-a820660f017d"></div>End of <strong>while loop</strong></blockquote><log>After 3 iterations, error in optimize_G_hv is 1.874e-15.</log><br/><log><em>G_hv</em> has shape: [[5, 5], [5, 5]]</log><br/></div>End of <strong>optimize_G_hv</strong></blockquote><blockquote><p class="folde4bda35e-64b1-11e7-924d-a820660f017d">Beginning of <strong>optimize_G_vh</strong>:</p><div class="unfolde4bda35e-64b1-11e7-924d-a820660f017d"><blockquote><p class="folde4bdb922-64b1-11e7-b1b2-a820660f017d">Beginning of <strong>while loop under cost_change > 1e-11 and counter < 10000</strong>:</p><div class="unfolde4bdb922-64b1-11e7-b1b2-a820660f017d"></div>End of <strong>while loop</strong></blockquote><log>After 3 iterations, error in optimize_G_vh is 1.338e-14.</log><br/><log><em>G_vh</em> has shape: [[5, 5], [5, 5]]</log><br/></div>End of <strong>optimize_G_vh</strong></blockquote>put G_hh,G_hv,G_vh into return value</div>End of <strong>TNR_step</strong></blockquote></div>End of <strong>generate_next_tensor</strong></blockquote></div>End of <strong>generate_tensor</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_tensor</strong></blockquote><blockquote><p class="folde4c2d270-64b1-11e7-a4a2-a820660f017d">Beginning of <strong>get_tensor</strong>:</p><div class="unfolde4c2d270-64b1-11e7-a4a2-a820660f017d"><blockquote><p class="folde4c2d61c-64b1-11e7-b483-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfolde4c2d61c-64b1-11e7-b483-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="folde4c2d86c-64b1-11e7-ab2e-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfolde4c2d86c-64b1-11e7-ab2e-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote><blockquote><p class="folde4c2e2ee-64b1-11e7-82b6-a820660f017d">Beginning of <strong>generate_tensor</strong>:</p><div class="unfolde4c2e2ee-64b1-11e7-82b6-a820660f017d"><blockquote><p class="folde4c2e69a-64b1-11e7-8209-a820660f017d">Beginning of <strong>generate_next_tensor</strong>:</p><div class="unfolde4c2e69a-64b1-11e7-8209-a820660f017d"><blockquote><p class="folde4c2e8fa-64b1-11e7-b148-a820660f017d">Beginning of <strong>get_tensor</strong>:</p><div class="unfolde4c2e8fa-64b1-11e7-b148-a820660f017d"><blockquote><p class="folde4c2eb36-64b1-11e7-a188-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfolde4c2eb36-64b1-11e7-a188-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="folde4c2edb6-64b1-11e7-b12c-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfolde4c2edb6-64b1-11e7-b12c-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_tensor</strong></blockquote> Coarse-graining, iter_count = #2: / <br/><blockquote><p class="folde4c3249a-64b1-11e7-aff0-a820660f017d">Beginning of <strong>get_gauges</strong>:</p><div class="unfolde4c3249a-64b1-11e7-aff0-a820660f017d"><blockquote><p class="folde4c329f0-64b1-11e7-b1c7-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfolde4c329f0-64b1-11e7-b1c7-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="folde4c32e66-64b1-11e7-b470-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfolde4c32e66-64b1-11e7-b470-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_gauges</strong></blockquote><blockquote><p class="folde4d2b610-64b1-11e7-8bde-a820660f017d">Beginning of <strong>get_pieces</strong>:</p><div class="unfolde4d2b610-64b1-11e7-8bde-a820660f017d"><blockquote><p class="folde4d2b93a-64b1-11e7-b16e-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfolde4d2b93a-64b1-11e7-b16e-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="folde4d2bb38-64b1-11e7-9e84-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfolde4d2bb38-64b1-11e7-9e84-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_pieces</strong></blockquote><blockquote><p class="folde4d30598-64b1-11e7-b361-a820660f017d">Beginning of <strong>TNR_step</strong>:</p><div class="unfolde4d30598-64b1-11e7-b361-a820660f017d">The function <strong>format_parameters</strong> formats some of the parameters given to <em>tnr_step</em> to a canonical form.<br/><ul>
    <li>Make sure <em>A_list</em> is a list of 2 tensors</li>
    <li>Create pars, gauges and pieces.</li>
    <li>Values are taken primarily from kwargs, then from pars, gauges and pieces, and finally from default. Only ones listed in defaults are used, others are ignored.</li>
    <li>Make sure <em>chis_tnr</em> and <em>chis_trg</em> are a lists of integers (or at least singlet lists of one integer) and sorted from small to large.</li>
    <li>If several chis to loop over are given but there is no epsilon to determine sufficient accuracy, then just use the largest chi.</li>
    </ul><blockquote><p class="folde4d30b2e-64b1-11e7-a482-a820660f017d">Beginning of <strong>symmetrize_A_list</strong>:</p><div class="unfolde4d30b2e-64b1-11e7-a482-a820660f017d"> Symmetrizes <em>A_list</em> according to the value of <em>horz_refl</em>. <br/><p class="param_use"><em>horz_relf</em> is true, transpose A[0] to get A[1]</p></div>End of <strong>symmetrize_A_list</strong></blockquote><blockquote><p class="folde4d37be8-64b1-11e7-9055-a820660f017d">Beginning of <strong>split_A_list</strong>:</p><div class="unfolde4d37be8-64b1-11e7-9055-a820660f017d"> SVDs the tensors in A_list and returns a list of lists with the parts in them. See split_A for details.<br/><blockquote><p class="folde4d38052-64b1-11e7-95fe-a820660f017d">Beginning of <strong>split_A</strong>:</p><div class="unfolde4d38052-64b1-11e7-95fe-a820660f017d"><log>Shape of A is[[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/> <br/>Splits an A tensor by SVD into two. eps is the tolerance in the
    SVD, <em>chis</em> is the list of bond dimensions to try when splitting (by
    default the full possible range is tried) and direction specifies
    the way to split.  If direction == 'nesw' (case and space
    insensitive) the splitting is done so that the northeast and
    southwest components are created, and similarly for direction ==
    'nwse'. For all other values of direction both splittings are done.
    The values are returned in the order A_NW, A_SE, A_NE, A_SW,
    possibly leaving out some based on direction.<br/>
    <br/><log>Split A NWSE with chi=36</log><br/><log>split A in NWSE direction,bond dimensions are like:<br/>A_NW:[[5, 5], [5, 5], [18, 18]]<br/>A_SE:[[18, 18], [5, 5], [5, 5]]<br/></log>The final result of split_A is a list, of which the elements are like A_NW,..., and each element has three external legs.<br/></div>End of <strong>split_A</strong></blockquote><blockquote><p class="folde4d4589c-64b1-11e7-8143-a820660f017d">Beginning of <strong>split_A</strong>:</p><div class="unfolde4d4589c-64b1-11e7-8143-a820660f017d"><log>Shape of A is[[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/> <br/>Splits an A tensor by SVD into two. eps is the tolerance in the
    SVD, <em>chis</em> is the list of bond dimensions to try when splitting (by
    default the full possible range is tried) and direction specifies
    the way to split.  If direction == 'nesw' (case and space
    insensitive) the splitting is done so that the northeast and
    southwest components are created, and similarly for direction ==
    'nwse'. For all other values of direction both splittings are done.
    The values are returned in the order A_NW, A_SE, A_NE, A_SW,
    possibly leaving out some based on direction.<br/>
    <log>Split A NESW with chi=36<br/>split A in NESW direction,bond dimensions are like:<br/>A_NE:[[5, 5], [5, 5], [18, 18]]<br/>A_SW:[[5, 5], [18, 18], [5, 5]]</log><br/>The final result of split_A is a list, of which the elements are like A_NW,..., and each element has three external legs.<br/></div>End of <strong>split_A</strong></blockquote>A_part_list = [split(A[0],nwse),split(A[1],nesw)]<br/>A_part_list[0]=split(A0,nwse)<br/>A_part_list[1]=split(A1,nesw)<br/>A_part_list[0][0]=A_NW<br/>A_part_list[0][1]=A_SE<br/>A_part_list[1][0]=A_NE<br/>A_part_list[1][1]=A_SW</div>End of <strong>split_A_list</strong></blockquote> store the result of <strong>split_A_list</strong> to <em>A_part_list</em><br/>
    A_part_list in only used in upb when pars[use_part] is true, otherwise this A_part_list is never used.<br>
     use SVDed A if chi_split < chi_orig**(3/2)<br/>calculate <em>chi_orig</em> and <em>chi_split</em> from <em>A_NW</em>,then determine whether to use the SVD of the original tensor, based on a rough estimate of whether it's computationally advantageous.<iptt>pars["use_parts"] = chi_split < chi_orig**(3/2)</iptt>Not using the SVDed A.<br/><br/>Obtain the optimized <em>u,v,w</em>.<br/><blockquote><p class="folde4d5506e-64b1-11e7-bc38-a820660f017d">Beginning of <strong>build_uvw</strong>:</p><div class="unfolde4d5506e-64b1-11e7-bc38-a820660f017d">This function optimize the u,v_R,v_L independently(linearly) as in the paper.<br/>Loop over growing truncation dimensions until the truncation error is small enough.<br/><br/> recall that chi_prime < chi^2, so the truncation dimension grows from chi to chi_prime after one TNR step<br/><blockquote><p class="folde4d68e5c-64b1-11e7-bc46-a820660f017d">Beginning of <strong>for loop</strong>:</p><div class="unfolde4d68e5c-64b1-11e7-bc46-a820660f017d"><pre>for <em>chi_num, chi</em> in enumerate(pars["chis_tnr"]):</pre><br/>loop over <em>chis_tnr</em> the bond dimension<br/><enumerate object at 0x10d889990><br/>Optimizing for chi = 6.<br/><blockquote><p class="folde4d69318-64b1-11e7-a281-a820660f017d">Beginning of <strong>initial_uvw</strong>:</p><div class="unfolde4d69318-64b1-11e7-a281-a820660f017d"> Returns the initial disentangler and isometries that are the starting point of the optimization. The initial u is the identity, the initial isometries are SVDed from A just like in TRG, truncated to dimension chi.<br/>the initial u is an identity tensor: u = scon((eye1, eye2), ([-1,-3], [-4,-2]))<br>the initial v_L and v_R are results from svd of A: w_dg = A_list[0].svd((0,1), (2,3), chis=chi)[0]<br/>v_dg = A_list[1].svd((0,3), (1,2), chis=chi)[2]<br/><log>initial u has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/><log>initial v has shape: [[5, 5], [3, 3], [5, 5]]</log><br/><log>initial w has shape: [[3, 3], [5, 5], [5, 5]]</log><br/></div>End of <strong>initial_uvw</strong></blockquote>there is <iptt>a while loop in this for loop</iptt> to optimize u,v,w<br/><pre>while (cost_change > pars["opt_eps_conv"] and counter < pars["opt_max_iter"]):
                counter += 1
                old_cost = new_cost
                v, w = <strong>optimize_isometries</strong>(u, v, w, A_list, A_part_list, pars, gauges)
                u, B_norm = <strong>optimize_disentangler</strong>(u, v, w, A_list, A_part_list, pars, return_B_norm=True)</pre><br/> keep optimizing u,v,w iteratively to <iptt>maximize the norm of B</iptt> until the relative change is less than <em>opt_eps_conv</em>. if convergence is not reached in <em>opt_max_iter</em> steps, stop and move on</div>End of <strong>for loop</strong></blockquote><log>Truncated bond dimension in TNR: 6</log><br/><log>Optimization converged after 4041 iterations.</log><br/><log>Relative error in optimized, truncated TNR block is: 1.108e-03 + 0j</log><br/><log>u has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/><log>v has shape: [[5, 5], [3, 3], [5, 5]]</log><br/><log>w has shape: [[3, 3], [5, 5], [5, 5]]</log><br/></div>End of <strong>build_uvw</strong></blockquote>Build the intermediate tensors <em>B</em> and <em>z</em> and use them to derive <em>A_new</em>.<br/><blockquote><p class="fold735eeb4a-64b2-11e7-87ab-a820660f017d">Beginning of <strong>build_B</strong>:</p><div class="unfold735eeb4a-64b2-11e7-87ab-a820660f017d"></div>End of <strong>build_B</strong></blockquote>This step is very simple, since <em>upb</em> (the upper half of B) is totally determined by <em>u,v,w</em> and <em>A</em>, just contract <em>upb</em> with upb^dagger<br/><br/><log>before splitting B has shape: [[3, 3], [3, 3], [3, 3], [3, 3]]</log><br/><blockquote><p class="fold73609ce4-64b2-11e7-a485-a820660f017d">Beginning of <strong>split_B</strong>:</p><div class="unfold73609ce4-64b2-11e7-a485-a820660f017d">no optimization in split_B, just take out the SVDed value<br/><log>The splitting result has shape:<br/>US (should be U*sqrt(S) ): [[3, 3], [5, 5], [3, 3]]<br/>SV (should be sqrt(S)*V ): [[5, 5], [3, 3], [3, 3]]<br/></log><log>Truncated bond dimension in split_B: 10</log><br/></div>End of <strong>split_B</strong></blockquote>split B horizontally, BUS,BSV = B.svd((0,3), (1,2))<br/>obtain <em>BUS, BSV</em> from <strong>split_B</strong>.<br/> <div class="codeblock">splitting B with chis=chis_trg</div><p class="param_use"><em>return_gauges</em> is true, then derive <em>G_hh</em> from <strong>split_B</strong></p><blockquote><p class="fold7360fbd0-64b2-11e7-9f62-a820660f017d">Beginning of <strong>build_z</strong>:</p><div class="unfold7360fbd0-64b2-11e7-9f62-a820660f017d">also no optimization in build_z, calculate the environment <em>M</em> and SVD it.<br/><log>the environment of z has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/><log>z has shape: [[5, 5], [5, 5], [5, 5]]</log><br/><log>Truncated bond dimension in build_z: 10</log><br/></div>End of <strong>build_z</strong></blockquote>mapping from the parameters used here to that used in the paper'algorithms in TNR'
    <pre>
    u ---> u
    w ---> v_L
    v ---> v_R
    z ---> w
    </pre>
    <blockquote><p class="fold73637db8-64b2-11e7-ae06-a820660f017d">Beginning of <strong>build_A_new</strong>:</p><div class="unfold73637db8-64b2-11e7-ae06-a820660f017d"><log><em>A_new</em> has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/></div>End of <strong>build_A_new</strong></blockquote>Scale A_new to have largest values around unity and use that to update new_log_fact.<br/>normalize <em>A_new</em> to have unit norm<br><iptt>new_log_fact = np.log(fact) + 4*log_fact</iptt>, here <em>fact</em> is the original norm of <em>A_new</em>, <em>log_fact is inherited from pars[...]</em><br/>obtain renewed <strong>A_new,BUS,BSV,z</strong> from <strong>fix_A_new_gauge</strong><p class="param_use"><br/>also obtain G_hh if "return_gauges" is true</p><blockquote><p class="fold7364cd46-64b2-11e7-8e18-a820660f017d">Beginning of <strong>fix_A_new_gauge</strong>:</p><div class="unfold7364cd46-64b2-11e7-8e18-a820660f017d"><blockquote><p class="fold73652110-64b2-11e7-ac17-a820660f017d">Beginning of <strong>while loop under cost_change > 1e-11 and counter < 10000</strong>:</p><div class="unfold73652110-64b2-11e7-ac17-a820660f017d"><blockquote><p class="fold7365230c-64b2-11e7-b8f2-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfold7365230c-64b2-11e7-b8f2-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="fold7366059e-64b2-11e7-90de-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfold7366059e-64b2-11e7-90de-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote><blockquote><p class="fold736714fe-64b2-11e7-b75f-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfold736714fe-64b2-11e7-b75f-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="fold73680d8a-64b2-11e7-9f5e-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfold73680d8a-64b2-11e7-9f5e-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote><blockquote><p class="fold7368fa2e-64b2-11e7-9c45-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfold7368fa2e-64b2-11e7-9c45-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="fold736a07ca-64b2-11e7-925a-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfold736a07ca-64b2-11e7-925a-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote><blockquote><p class="fold736af84c-64b2-11e7-9c81-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfold736af84c-64b2-11e7-9c81-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="fold736bcf42-64b2-11e7-adc7-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfold736bcf42-64b2-11e7-adc7-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote><blockquote><p class="fold736ced9e-64b2-11e7-84d8-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfold736ced9e-64b2-11e7-84d8-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="fold736dd5dc-64b2-11e7-82f1-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfold736dd5dc-64b2-11e7-82f1-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote><blockquote><p class="fold736f1864-64b2-11e7-a6f9-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfold736f1864-64b2-11e7-a6f9-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="fold737004cc-64b2-11e7-8679-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfold737004cc-64b2-11e7-8679-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote></div>End of <strong>while loop</strong></blockquote><blockquote><p class="fold7370ef18-64b2-11e7-8658-a820660f017d">Beginning of <strong>fix_A_new_gauge_update_to_gauge</strong>:</p><div class="unfold7370ef18-64b2-11e7-8658-a820660f017d"></div>End of <strong>fix_A_new_gauge_update_to_gauge</strong></blockquote></div>End of <strong>fix_A_new_gauge</strong></blockquote>Put A_new,new_log_fact to return value<br><p class="param_use">return_pieces is true, put A_part_list,u,v,w,B,BUS,BSV,z into return value</p><p class="param_use">return_gauges & horz_refl true, then optimize_G_hv</p><blockquote><p class="fold73726226-64b2-11e7-80a0-a820660f017d">Beginning of <strong>optimize_G_hv</strong>:</p><div class="unfold73726226-64b2-11e7-80a0-a820660f017d"><blockquote><p class="fold7372dac6-64b2-11e7-8db1-a820660f017d">Beginning of <strong>while loop under cost_change > 1e-11 and counter < 10000</strong>:</p><div class="unfold7372dac6-64b2-11e7-8db1-a820660f017d"></div>End of <strong>while loop</strong></blockquote><log>After 3 iterations, error in optimize_G_hv is 2.551e-15.</log><br/><log><em>G_hv</em> has shape: [[5, 5], [5, 5]]</log><br/></div>End of <strong>optimize_G_hv</strong></blockquote><blockquote><p class="fold73757a10-64b2-11e7-8c53-a820660f017d">Beginning of <strong>optimize_G_vh</strong>:</p><div class="unfold73757a10-64b2-11e7-8c53-a820660f017d"><blockquote><p class="fold73758762-64b2-11e7-82bc-a820660f017d">Beginning of <strong>while loop under cost_change > 1e-11 and counter < 10000</strong>:</p><div class="unfold73758762-64b2-11e7-82bc-a820660f017d"></div>End of <strong>while loop</strong></blockquote><log>After 3 iterations, error in optimize_G_vh is 2.512e-15.</log><br/><log><em>G_vh</em> has shape: [[5, 5], [5, 5]]</log><br/></div>End of <strong>optimize_G_vh</strong></blockquote>put G_hh,G_hv,G_vh into return value</div>End of <strong>TNR_step</strong></blockquote></div>End of <strong>generate_next_tensor</strong></blockquote></div>End of <strong>generate_tensor</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_tensor</strong></blockquote><blockquote><p class="fold7378e222-64b2-11e7-bf9e-a820660f017d">Beginning of <strong>get_tensor</strong>:</p><div class="unfold7378e222-64b2-11e7-bf9e-a820660f017d"><blockquote><p class="fold7378e4d4-64b2-11e7-af81-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfold7378e4d4-64b2-11e7-af81-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="fold7378e6f0-64b2-11e7-8152-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfold7378e6f0-64b2-11e7-8152-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote><blockquote><p class="fold7378f01c-64b2-11e7-8636-a820660f017d">Beginning of <strong>generate_tensor</strong>:</p><div class="unfold7378f01c-64b2-11e7-8636-a820660f017d"><blockquote><p class="fold7378f1fe-64b2-11e7-be94-a820660f017d">Beginning of <strong>generate_next_tensor</strong>:</p><div class="unfold7378f1fe-64b2-11e7-be94-a820660f017d"><blockquote><p class="fold7378f3ac-64b2-11e7-bec4-a820660f017d">Beginning of <strong>get_tensor</strong>:</p><div class="unfold7378f3ac-64b2-11e7-bec4-a820660f017d"><blockquote><p class="fold7378f5ee-64b2-11e7-8576-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfold7378f5ee-64b2-11e7-8576-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="fold7378f9c2-64b2-11e7-b9c4-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfold7378f9c2-64b2-11e7-b9c4-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_tensor</strong></blockquote> Coarse-graining, iter_count = #3: / <br/><blockquote><p class="fold73791742-64b2-11e7-b964-a820660f017d">Beginning of <strong>get_gauges</strong>:</p><div class="unfold73791742-64b2-11e7-b964-a820660f017d"><blockquote><p class="fold73791a64-64b2-11e7-9f65-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfold73791a64-64b2-11e7-9f65-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="fold73791c92-64b2-11e7-b37f-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfold73791c92-64b2-11e7-b37f-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_gauges</strong></blockquote><blockquote><p class="fold73792b68-64b2-11e7-8155-a820660f017d">Beginning of <strong>get_pieces</strong>:</p><div class="unfold73792b68-64b2-11e7-8155-a820660f017d"><blockquote><p class="fold73792d40-64b2-11e7-9635-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfold73792d40-64b2-11e7-9635-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="fold73792f28-64b2-11e7-877b-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfold73792f28-64b2-11e7-877b-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_pieces</strong></blockquote><blockquote><p class="fold73795450-64b2-11e7-9d1e-a820660f017d">Beginning of <strong>TNR_step</strong>:</p><div class="unfold73795450-64b2-11e7-9d1e-a820660f017d">The function <strong>format_parameters</strong> formats some of the parameters given to <em>tnr_step</em> to a canonical form.<br/><ul>
    <li>Make sure <em>A_list</em> is a list of 2 tensors</li>
    <li>Create pars, gauges and pieces.</li>
    <li>Values are taken primarily from kwargs, then from pars, gauges and pieces, and finally from default. Only ones listed in defaults are used, others are ignored.</li>
    <li>Make sure <em>chis_tnr</em> and <em>chis_trg</em> are a lists of integers (or at least singlet lists of one integer) and sorted from small to large.</li>
    <li>If several chis to loop over are given but there is no epsilon to determine sufficient accuracy, then just use the largest chi.</li>
    </ul><blockquote><p class="fold737958a4-64b2-11e7-8e9d-a820660f017d">Beginning of <strong>symmetrize_A_list</strong>:</p><div class="unfold737958a4-64b2-11e7-8e9d-a820660f017d"> Symmetrizes <em>A_list</em> according to the value of <em>horz_refl</em>. <br/><p class="param_use"><em>horz_relf</em> is true, transpose A[0] to get A[1]</p></div>End of <strong>symmetrize_A_list</strong></blockquote><blockquote><p class="fold7379c42e-64b2-11e7-b41f-a820660f017d">Beginning of <strong>split_A_list</strong>:</p><div class="unfold7379c42e-64b2-11e7-b41f-a820660f017d"> SVDs the tensors in A_list and returns a list of lists with the parts in them. See split_A for details.<br/><blockquote><p class="fold7379c8fe-64b2-11e7-a083-a820660f017d">Beginning of <strong>split_A</strong>:</p><div class="unfold7379c8fe-64b2-11e7-a083-a820660f017d"><log>Shape of A is[[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/> <br/>Splits an A tensor by SVD into two. eps is the tolerance in the
    SVD, <em>chis</em> is the list of bond dimensions to try when splitting (by
    default the full possible range is tried) and direction specifies
    the way to split.  If direction == 'nesw' (case and space
    insensitive) the splitting is done so that the northeast and
    southwest components are created, and similarly for direction ==
    'nwse'. For all other values of direction both splittings are done.
    The values are returned in the order A_NW, A_SE, A_NE, A_SW,
    possibly leaving out some based on direction.<br/>
    <br/><log>Split A NWSE with chi=36</log><br/><log>split A in NWSE direction,bond dimensions are like:<br/>A_NW:[[5, 5], [5, 5], [18, 18]]<br/>A_SE:[[18, 18], [5, 5], [5, 5]]<br/></log>The final result of split_A is a list, of which the elements are like A_NW,..., and each element has three external legs.<br/></div>End of <strong>split_A</strong></blockquote><blockquote><p class="fold737a7bbe-64b2-11e7-addf-a820660f017d">Beginning of <strong>split_A</strong>:</p><div class="unfold737a7bbe-64b2-11e7-addf-a820660f017d"><log>Shape of A is[[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/> <br/>Splits an A tensor by SVD into two. eps is the tolerance in the
    SVD, <em>chis</em> is the list of bond dimensions to try when splitting (by
    default the full possible range is tried) and direction specifies
    the way to split.  If direction == 'nesw' (case and space
    insensitive) the splitting is done so that the northeast and
    southwest components are created, and similarly for direction ==
    'nwse'. For all other values of direction both splittings are done.
    The values are returned in the order A_NW, A_SE, A_NE, A_SW,
    possibly leaving out some based on direction.<br/>
    <log>Split A NESW with chi=36<br/>split A in NESW direction,bond dimensions are like:<br/>A_NE:[[5, 5], [5, 5], [18, 18]]<br/>A_SW:[[5, 5], [18, 18], [5, 5]]</log><br/>The final result of split_A is a list, of which the elements are like A_NW,..., and each element has three external legs.<br/></div>End of <strong>split_A</strong></blockquote>A_part_list = [split(A[0],nwse),split(A[1],nesw)]<br/>A_part_list[0]=split(A0,nwse)<br/>A_part_list[1]=split(A1,nesw)<br/>A_part_list[0][0]=A_NW<br/>A_part_list[0][1]=A_SE<br/>A_part_list[1][0]=A_NE<br/>A_part_list[1][1]=A_SW</div>End of <strong>split_A_list</strong></blockquote> store the result of <strong>split_A_list</strong> to <em>A_part_list</em><br/>
    A_part_list in only used in upb when pars[use_part] is true, otherwise this A_part_list is never used.<br>
     use SVDed A if chi_split < chi_orig**(3/2)<br/>calculate <em>chi_orig</em> and <em>chi_split</em> from <em>A_NW</em>,then determine whether to use the SVD of the original tensor, based on a rough estimate of whether it's computationally advantageous.<iptt>pars["use_parts"] = chi_split < chi_orig**(3/2)</iptt>Not using the SVDed A.<br/><br/>Obtain the optimized <em>u,v,w</em>.<br/><blockquote><p class="fold737b38f6-64b2-11e7-a3f3-a820660f017d">Beginning of <strong>build_uvw</strong>:</p><div class="unfold737b38f6-64b2-11e7-a3f3-a820660f017d">This function optimize the u,v_R,v_L independently(linearly) as in the paper.<br/>Loop over growing truncation dimensions until the truncation error is small enough.<br/><br/> recall that chi_prime < chi^2, so the truncation dimension grows from chi to chi_prime after one TNR step<br/><blockquote><p class="fold737c3f94-64b2-11e7-8736-a820660f017d">Beginning of <strong>for loop</strong>:</p><div class="unfold737c3f94-64b2-11e7-8736-a820660f017d"><pre>for <em>chi_num, chi</em> in enumerate(pars["chis_tnr"]):</pre><br/>loop over <em>chis_tnr</em> the bond dimension<br/><enumerate object at 0x10d839120><br/>Optimizing for chi = 6.<br/><blockquote><p class="fold737c44d0-64b2-11e7-8f88-a820660f017d">Beginning of <strong>initial_uvw</strong>:</p><div class="unfold737c44d0-64b2-11e7-8f88-a820660f017d"> Returns the initial disentangler and isometries that are the starting point of the optimization. The initial u is the identity, the initial isometries are SVDed from A just like in TRG, truncated to dimension chi.<br/><br/><log>initial u has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/><log>initial v has shape: [[5, 5], [3, 3], [5, 5]]</log><br/><log>initial w has shape: [[3, 3], [5, 5], [5, 5]]</log><br/></div>End of <strong>initial_uvw</strong></blockquote>there is <iptt>a while loop in this for loop</iptt> to optimize u,v,w<br/><pre>while (cost_change > pars["opt_eps_conv"] and counter < pars["opt_max_iter"]):
                counter += 1
                old_cost = new_cost
                v, w = <strong>optimize_isometries</strong>(u, v, w, A_list, A_part_list, pars, gauges)
                u, B_norm = <strong>optimize_disentangler</strong>(u, v, w, A_list, A_part_list, pars, return_B_norm=True)</pre><br/> keep optimizing u,v,w iteratively to <iptt>maximize the norm of B</iptt> until the relative change is less than <em>opt_eps_conv</em>. if convergence is not reached in <em>opt_max_iter</em> steps, stop and move on</div>End of <strong>for loop</strong></blockquote><log>Truncated bond dimension in TNR: 6</log><br/><log>Optimization converged after 1696 iterations.</log><br/><log>Relative error in optimized, truncated TNR block is: 1.505e-03 + 0j</log><br/><log>u has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/><log>v has shape: [[5, 5], [3, 3], [5, 5]]</log><br/><log>w has shape: [[3, 3], [5, 5], [5, 5]]</log><br/></div>End of <strong>build_uvw</strong></blockquote>Build the intermediate tensors <em>B</em> and <em>z</em> and use them to derive <em>A_new</em>.<br/><blockquote><p class="foldaf7928ae-64b2-11e7-931f-a820660f017d">Beginning of <strong>build_B</strong>:</p><div class="unfoldaf7928ae-64b2-11e7-931f-a820660f017d"></div>End of <strong>build_B</strong></blockquote>This step is very simple, since <em>upb</em> (the upper half of B) is totally determined by <em>u,v,w</em> and <em>A</em>, just contract <em>upb</em> with upb^dagger<br/><br/><log>before splitting B has shape: [[3, 3], [3, 3], [3, 3], [3, 3]]</log><br/><blockquote><p class="foldaf7af682-64b2-11e7-9cf8-a820660f017d">Beginning of <strong>split_B</strong>:</p><div class="unfoldaf7af682-64b2-11e7-9cf8-a820660f017d">no optimization in split_B, just take out the SVDed value<br/><log>The splitting result has shape:<br/>US (should be U*sqrt(S) ): [[3, 3], [5, 5], [3, 3]]<br/>SV (should be sqrt(S)*V ): [[5, 5], [3, 3], [3, 3]]<br/></log><log>Truncated bond dimension in split_B: 10</log><br/></div>End of <strong>split_B</strong></blockquote>split B horizontally, BUS,BSV = B.svd((0,3), (1,2))<br/>obtain <em>BUS, BSV</em> from <strong>split_B</strong>.<br/> <div class="codeblock">splitting B with chis=chis_trg</div><p class="param_use"><em>return_gauges</em> is true, then derive <em>G_hh</em> from <strong>split_B</strong></p><blockquote><p class="foldaf7b5e6c-64b2-11e7-81f7-a820660f017d">Beginning of <strong>build_z</strong>:</p><div class="unfoldaf7b5e6c-64b2-11e7-81f7-a820660f017d">also no optimization in build_z, calculate the environment <em>M</em> and SVD it.<br/><log>the environment of z has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/><log>z has shape: [[5, 5], [5, 5], [5, 5]]</log><br/><log>Truncated bond dimension in build_z: 10</log><br/></div>End of <strong>build_z</strong></blockquote>mapping from the parameters used here to that used in the paper'algorithms in TNR'
    <pre>
    u ---> u
    w ---> v_L
    v ---> v_R
    z ---> w
    </pre>
    <blockquote><p class="foldaf7dda52-64b2-11e7-89ad-a820660f017d">Beginning of <strong>build_A_new</strong>:</p><div class="unfoldaf7dda52-64b2-11e7-89ad-a820660f017d"><log><em>A_new</em> has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/></div>End of <strong>build_A_new</strong></blockquote>Scale A_new to have largest values around unity and use that to update new_log_fact.<br/>normalize <em>A_new</em> to have unit norm<br><iptt>new_log_fact = np.log(fact) + 4*log_fact</iptt>, here <em>fact</em> is the original norm of <em>A_new</em>, <em>log_fact is inherited from pars[...]</em><br/>obtain renewed <strong>A_new,BUS,BSV,z</strong> from <strong>fix_A_new_gauge</strong><p class="param_use"><br/>also obtain G_hh if "return_gauges" is true</p><blockquote><p class="foldaf7f0fd2-64b2-11e7-abcd-a820660f017d">Beginning of <strong>fix_A_new_gauge</strong>:</p><div class="unfoldaf7f0fd2-64b2-11e7-abcd-a820660f017d"><blockquote><p class="foldaf7f5c92-64b2-11e7-a62b-a820660f017d">Beginning of <strong>while loop under cost_change > 1e-11 and counter < 10000</strong>:</p><div class="unfoldaf7f5c92-64b2-11e7-a62b-a820660f017d"><blockquote><p class="foldaf7f5eae-64b2-11e7-923e-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldaf7f5eae-64b2-11e7-923e-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldaf806b14-64b2-11e7-89a2-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldaf806b14-64b2-11e7-89a2-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote><blockquote><p class="foldaf815ef4-64b2-11e7-b289-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldaf815ef4-64b2-11e7-b289-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldaf8258d4-64b2-11e7-b7df-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldaf8258d4-64b2-11e7-b7df-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote><blockquote><p class="foldaf8357dc-64b2-11e7-b0b9-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldaf8357dc-64b2-11e7-b0b9-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldaf842fec-64b2-11e7-8753-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldaf842fec-64b2-11e7-8753-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote><blockquote><p class="foldaf856c40-64b2-11e7-8751-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldaf856c40-64b2-11e7-8751-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldaf865286-64b2-11e7-805f-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldaf865286-64b2-11e7-805f-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote><blockquote><p class="foldaf8767d2-64b2-11e7-8c8f-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldaf8767d2-64b2-11e7-8c8f-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldaf88610c-64b2-11e7-b46b-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldaf88610c-64b2-11e7-b46b-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote><blockquote><p class="foldaf89b870-64b2-11e7-9215-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldaf89b870-64b2-11e7-9215-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldaf8ae394-64b2-11e7-a6a2-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldaf8ae394-64b2-11e7-a6a2-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote></div>End of <strong>while loop</strong></blockquote><blockquote><p class="foldaf8bd44a-64b2-11e7-bea9-a820660f017d">Beginning of <strong>fix_A_new_gauge_update_to_gauge</strong>:</p><div class="unfoldaf8bd44a-64b2-11e7-bea9-a820660f017d"></div>End of <strong>fix_A_new_gauge_update_to_gauge</strong></blockquote></div>End of <strong>fix_A_new_gauge</strong></blockquote>Put A_new,new_log_fact to return value<br><p class="param_use">return_pieces is true, put A_part_list,u,v,w,B,BUS,BSV,z into return value</p><p class="param_use">return_gauges & horz_refl true, then optimize_G_hv</p><blockquote><p class="foldaf8d46e8-64b2-11e7-8230-a820660f017d">Beginning of <strong>optimize_G_hv</strong>:</p><div class="unfoldaf8d46e8-64b2-11e7-8230-a820660f017d"><blockquote><p class="foldaf8db04c-64b2-11e7-abf8-a820660f017d">Beginning of <strong>while loop under cost_change > 1e-11 and counter < 10000</strong>:</p><div class="unfoldaf8db04c-64b2-11e7-abf8-a820660f017d"></div>End of <strong>while loop</strong></blockquote><log>After 3 iterations, error in optimize_G_hv is 1.245e-14.</log><br/><log><em>G_hv</em> has shape: [[5, 5], [5, 5]]</log><br/></div>End of <strong>optimize_G_hv</strong></blockquote><blockquote><p class="foldaf907006-64b2-11e7-b2ad-a820660f017d">Beginning of <strong>optimize_G_vh</strong>:</p><div class="unfoldaf907006-64b2-11e7-b2ad-a820660f017d"><blockquote><p class="foldaf907da6-64b2-11e7-9e17-a820660f017d">Beginning of <strong>while loop under cost_change > 1e-11 and counter < 10000</strong>:</p><div class="unfoldaf907da6-64b2-11e7-9e17-a820660f017d"></div>End of <strong>while loop</strong></blockquote><log>After 3 iterations, error in optimize_G_vh is 3.940e-15.</log><br/><log><em>G_vh</em> has shape: [[5, 5], [5, 5]]</log><br/></div>End of <strong>optimize_G_vh</strong></blockquote>put G_hh,G_hv,G_vh into return value</div>End of <strong>TNR_step</strong></blockquote></div>End of <strong>generate_next_tensor</strong></blockquote></div>End of <strong>generate_tensor</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_tensor</strong></blockquote><blockquote><p class="foldaf93d05a-64b2-11e7-958c-a820660f017d">Beginning of <strong>get_tensor</strong>:</p><div class="unfoldaf93d05a-64b2-11e7-958c-a820660f017d"><blockquote><p class="foldaf93d328-64b2-11e7-bf05-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfoldaf93d328-64b2-11e7-bf05-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="foldaf93d5b6-64b2-11e7-8625-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfoldaf93d5b6-64b2-11e7-8625-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote><blockquote><p class="foldaf93dd0a-64b2-11e7-a254-a820660f017d">Beginning of <strong>generate_tensor</strong>:</p><div class="unfoldaf93dd0a-64b2-11e7-a254-a820660f017d"><blockquote><p class="foldaf93df28-64b2-11e7-9292-a820660f017d">Beginning of <strong>generate_next_tensor</strong>:</p><div class="unfoldaf93df28-64b2-11e7-9292-a820660f017d"><blockquote><p class="foldaf93e112-64b2-11e7-8ffe-a820660f017d">Beginning of <strong>get_tensor</strong>:</p><div class="unfoldaf93e112-64b2-11e7-8ffe-a820660f017d"><blockquote><p class="foldaf93e34a-64b2-11e7-896d-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfoldaf93e34a-64b2-11e7-896d-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="foldaf93e54a-64b2-11e7-8c76-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfoldaf93e54a-64b2-11e7-8c76-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_tensor</strong></blockquote> Coarse-graining, iter_count = #4: / <br/><blockquote><p class="foldaf940662-64b2-11e7-9ac8-a820660f017d">Beginning of <strong>get_gauges</strong>:</p><div class="unfoldaf940662-64b2-11e7-9ac8-a820660f017d"><blockquote><p class="foldaf9415a6-64b2-11e7-ba29-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfoldaf9415a6-64b2-11e7-ba29-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="foldaf941b64-64b2-11e7-a9b8-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfoldaf941b64-64b2-11e7-a9b8-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_gauges</strong></blockquote><blockquote><p class="foldaf943188-64b2-11e7-a860-a820660f017d">Beginning of <strong>get_pieces</strong>:</p><div class="unfoldaf943188-64b2-11e7-a860-a820660f017d"><blockquote><p class="foldaf943446-64b2-11e7-bcc6-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfoldaf943446-64b2-11e7-bcc6-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="foldaf943694-64b2-11e7-ac5d-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfoldaf943694-64b2-11e7-ac5d-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_pieces</strong></blockquote><blockquote><p class="foldaf946a1a-64b2-11e7-abc5-a820660f017d">Beginning of <strong>TNR_step</strong>:</p><div class="unfoldaf946a1a-64b2-11e7-abc5-a820660f017d">The function <strong>format_parameters</strong> formats some of the parameters given to <em>tnr_step</em> to a canonical form.<br/><ul>
    <li>Make sure <em>A_list</em> is a list of 2 tensors</li>
    <li>Create pars, gauges and pieces.</li>
    <li>Values are taken primarily from kwargs, then from pars, gauges and pieces, and finally from default. Only ones listed in defaults are used, others are ignored.</li>
    <li>Make sure <em>chis_tnr</em> and <em>chis_trg</em> are a lists of integers (or at least singlet lists of one integer) and sorted from small to large.</li>
    <li>If several chis to loop over are given but there is no epsilon to determine sufficient accuracy, then just use the largest chi.</li>
    </ul><blockquote><p class="foldaf946fec-64b2-11e7-b928-a820660f017d">Beginning of <strong>symmetrize_A_list</strong>:</p><div class="unfoldaf946fec-64b2-11e7-b928-a820660f017d"> Symmetrizes <em>A_list</em> according to the value of <em>horz_refl</em>. <br/><p class="param_use"><em>horz_relf</em> is true, transpose A[0] to get A[1]</p></div>End of <strong>symmetrize_A_list</strong></blockquote><blockquote><p class="foldaf94dd2e-64b2-11e7-91cd-a820660f017d">Beginning of <strong>split_A_list</strong>:</p><div class="unfoldaf94dd2e-64b2-11e7-91cd-a820660f017d"> SVDs the tensors in A_list and returns a list of lists with the parts in them. See split_A for details.<br/><blockquote><p class="foldaf94e364-64b2-11e7-bb8e-a820660f017d">Beginning of <strong>split_A</strong>:</p><div class="unfoldaf94e364-64b2-11e7-bb8e-a820660f017d"><log>Shape of A is[[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/> <br/>Splits an A tensor by SVD into two. eps is the tolerance in the
    SVD, <em>chis</em> is the list of bond dimensions to try when splitting (by
    default the full possible range is tried) and direction specifies
    the way to split.  If direction == 'nesw' (case and space
    insensitive) the splitting is done so that the northeast and
    southwest components are created, and similarly for direction ==
    'nwse'. For all other values of direction both splittings are done.
    The values are returned in the order A_NW, A_SE, A_NE, A_SW,
    possibly leaving out some based on direction.<br/>
    <br/><log>Split A NWSE with chi=36</log><br/><log>split A in NWSE direction,bond dimensions are like:<br/>A_NW:[[5, 5], [5, 5], [18, 18]]<br/>A_SE:[[18, 18], [5, 5], [5, 5]]<br/></log>The final result of split_A is a list, of which the elements are like A_NW,..., and each element has three external legs.<br/></div>End of <strong>split_A</strong></blockquote><blockquote><p class="foldaf959a52-64b2-11e7-a4cb-a820660f017d">Beginning of <strong>split_A</strong>:</p><div class="unfoldaf959a52-64b2-11e7-a4cb-a820660f017d"><log>Shape of A is[[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/> <br/>Splits an A tensor by SVD into two. eps is the tolerance in the
    SVD, <em>chis</em> is the list of bond dimensions to try when splitting (by
    default the full possible range is tried) and direction specifies
    the way to split.  If direction == 'nesw' (case and space
    insensitive) the splitting is done so that the northeast and
    southwest components are created, and similarly for direction ==
    'nwse'. For all other values of direction both splittings are done.
    The values are returned in the order A_NW, A_SE, A_NE, A_SW,
    possibly leaving out some based on direction.<br/>
    <log>Split A NESW with chi=36<br/>split A in NESW direction,bond dimensions are like:<br/>A_NE:[[5, 5], [5, 5], [18, 18]]<br/>A_SW:[[5, 5], [18, 18], [5, 5]]</log><br/>The final result of split_A is a list, of which the elements are like A_NW,..., and each element has three external legs.<br/></div>End of <strong>split_A</strong></blockquote>A_part_list = [split(A[0],nwse),split(A[1],nesw)]<br/>A_part_list[0]=split(A0,nwse)<br/>A_part_list[1]=split(A1,nesw)<br/>A_part_list[0][0]=A_NW<br/>A_part_list[0][1]=A_SE<br/>A_part_list[1][0]=A_NE<br/>A_part_list[1][1]=A_SW</div>End of <strong>split_A_list</strong></blockquote> store the result of <strong>split_A_list</strong> to <em>A_part_list</em><br/>
    A_part_list in only used in upb when pars[use_part] is true, otherwise this A_part_list is never used.<br>
     use SVDed A if chi_split < chi_orig**(3/2)<br/>calculate <em>chi_orig</em> and <em>chi_split</em> from <em>A_NW</em>,then determine whether to use the SVD of the original tensor, based on a rough estimate of whether it's computationally advantageous.<iptt>pars["use_parts"] = chi_split < chi_orig**(3/2)</iptt>Not using the SVDed A.<br/><br/>Obtain the optimized <em>u,v,w</em>.<br/><blockquote><p class="foldaf964a4a-64b2-11e7-abbb-a820660f017d">Beginning of <strong>build_uvw</strong>:</p><div class="unfoldaf964a4a-64b2-11e7-abbb-a820660f017d">This function optimize the u,v_R,v_L independently(linearly) as in the paper.<br/>Loop over growing truncation dimensions until the truncation error is small enough.<br/><br/> recall that chi_prime < chi^2, so the truncation dimension grows from chi to chi_prime after one TNR step<br/><blockquote><p class="foldaf9757d4-64b2-11e7-bb12-a820660f017d">Beginning of <strong>for loop</strong>:</p><div class="unfoldaf9757d4-64b2-11e7-bb12-a820660f017d"><pre>for <em>chi_num, chi</em> in enumerate(pars["chis_tnr"]):</pre><br/>loop over <em>chis_tnr</em> the bond dimension<br/><enumerate object at 0x10d821b40><br/>Optimizing for chi = 6.<br/><blockquote><p class="foldaf975db0-64b2-11e7-81bd-a820660f017d">Beginning of <strong>initial_uvw</strong>:</p><div class="unfoldaf975db0-64b2-11e7-81bd-a820660f017d"> Returns the initial disentangler and isometries that are the starting point of the optimization. The initial u is the identity, the initial isometries are SVDed from A just like in TRG, truncated to dimension chi.<br/><br/><log>initial u has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/><log>initial v has shape: [[5, 5], [3, 3], [5, 5]]</log><br/><log>initial w has shape: [[3, 3], [5, 5], [5, 5]]</log><br/></div>End of <strong>initial_uvw</strong></blockquote>there is <iptt>a while loop in this for loop</iptt> to optimize u,v,w<br/><pre>while (cost_change > pars["opt_eps_conv"] and counter < pars["opt_max_iter"]):
                counter += 1
                old_cost = new_cost
                v, w = <strong>optimize_isometries</strong>(u, v, w, A_list, A_part_list, pars, gauges)
                u, B_norm = <strong>optimize_disentangler</strong>(u, v, w, A_list, A_part_list, pars, return_B_norm=True)</pre><br/> keep optimizing u,v,w iteratively to <iptt>maximize the norm of B</iptt> until the relative change is less than <em>opt_eps_conv</em>. if convergence is not reached in <em>opt_max_iter</em> steps, stop and move on</div>End of <strong>for loop</strong></blockquote><log>Truncated bond dimension in TNR: 6</log><br/><log>Optimization converged after 806 iterations.</log><br/><log>Relative error in optimized, truncated TNR block is: 1.356e-03 + 0j</log><br/><log>u has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/><log>v has shape: [[5, 5], [3, 3], [5, 5]]</log><br/><log>w has shape: [[3, 3], [5, 5], [5, 5]]</log><br/></div>End of <strong>build_uvw</strong></blockquote>Build the intermediate tensors <em>B</em> and <em>z</em> and use them to derive <em>A_new</em>.<br/><blockquote><p class="foldcb89c3b6-64b2-11e7-b1c0-a820660f017d">Beginning of <strong>build_B</strong>:</p><div class="unfoldcb89c3b6-64b2-11e7-b1c0-a820660f017d"></div>End of <strong>build_B</strong></blockquote>This step is very simple, since <em>upb</em> (the upper half of B) is totally determined by <em>u,v,w</em> and <em>A</em>, just contract <em>upb</em> with upb^dagger<br/><br/><log>before splitting B has shape: [[3, 3], [3, 3], [3, 3], [3, 3]]</log><br/><blockquote><p class="foldcb8b5602-64b2-11e7-a551-a820660f017d">Beginning of <strong>split_B</strong>:</p><div class="unfoldcb8b5602-64b2-11e7-a551-a820660f017d">no optimization in split_B, just take out the SVDed value<br/><log>The splitting result has shape:<br/>US (should be U*sqrt(S) ): [[3, 3], [5, 5], [3, 3]]<br/>SV (should be sqrt(S)*V ): [[5, 5], [3, 3], [3, 3]]<br/></log><log>Truncated bond dimension in split_B: 10</log><br/></div>End of <strong>split_B</strong></blockquote>split B horizontally, BUS,BSV = B.svd((0,3), (1,2))<br/>obtain <em>BUS, BSV</em> from <strong>split_B</strong>.<br/> <div class="codeblock">splitting B with chis=chis_trg</div><p class="param_use"><em>return_gauges</em> is true, then derive <em>G_hh</em> from <strong>split_B</strong></p><blockquote><p class="foldcb8bf152-64b2-11e7-8e32-a820660f017d">Beginning of <strong>build_z</strong>:</p><div class="unfoldcb8bf152-64b2-11e7-8e32-a820660f017d">also no optimization in build_z, calculate the environment <em>M</em> and SVD it.<br/><log>the environment of z has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/><log>z has shape: [[5, 5], [5, 5], [5, 5]]</log><br/><log>Truncated bond dimension in build_z: 10</log><br/></div>End of <strong>build_z</strong></blockquote>mapping from the parameters used here to that used in the paper'algorithms in TNR'
    <pre>
    u ---> u
    w ---> v_L
    v ---> v_R
    z ---> w
    </pre>
    <blockquote><p class="foldcb8e5cc8-64b2-11e7-a025-a820660f017d">Beginning of <strong>build_A_new</strong>:</p><div class="unfoldcb8e5cc8-64b2-11e7-a025-a820660f017d"><log><em>A_new</em> has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/></div>End of <strong>build_A_new</strong></blockquote>Scale A_new to have largest values around unity and use that to update new_log_fact.<br/>normalize <em>A_new</em> to have unit norm<br><iptt>new_log_fact = np.log(fact) + 4*log_fact</iptt>, here <em>fact</em> is the original norm of <em>A_new</em>, <em>log_fact is inherited from pars[...]</em><br/>obtain renewed <strong>A_new,BUS,BSV,z</strong> from <strong>fix_A_new_gauge</strong><p class="param_use"><br/>also obtain G_hh if "return_gauges" is true</p><blockquote><p class="foldcb8ff0e8-64b2-11e7-b930-a820660f017d">Beginning of <strong>fix_A_new_gauge</strong>:</p><div class="unfoldcb8ff0e8-64b2-11e7-b930-a820660f017d"><blockquote><p class="foldcb904a4a-64b2-11e7-8f91-a820660f017d">Beginning of <strong>while loop under cost_change > 1e-11 and counter < 10000</strong>:</p><div class="unfoldcb904a4a-64b2-11e7-8f91-a820660f017d"><blockquote><p class="foldcb904d06-64b2-11e7-a585-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldcb904d06-64b2-11e7-a585-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldcb91b902-64b2-11e7-b6ef-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldcb91b902-64b2-11e7-b6ef-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote><blockquote><p class="foldcb92a5d0-64b2-11e7-87b1-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldcb92a5d0-64b2-11e7-87b1-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldcb93bf4a-64b2-11e7-bfa1-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldcb93bf4a-64b2-11e7-bfa1-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote><blockquote><p class="foldcb94bbd4-64b2-11e7-81fc-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldcb94bbd4-64b2-11e7-81fc-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldcb95cab8-64b2-11e7-a0d4-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldcb95cab8-64b2-11e7-a0d4-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote><blockquote><p class="foldcb971940-64b2-11e7-a58c-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldcb971940-64b2-11e7-a58c-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldcb97f100-64b2-11e7-96d2-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldcb97f100-64b2-11e7-96d2-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote><blockquote><p class="foldcb991b78-64b2-11e7-8ec3-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldcb991b78-64b2-11e7-8ec3-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldcb9a0c54-64b2-11e7-b890-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldcb9a0c54-64b2-11e7-b890-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote></div>End of <strong>while loop</strong></blockquote><blockquote><p class="foldcb9b593a-64b2-11e7-aa61-a820660f017d">Beginning of <strong>fix_A_new_gauge_update_to_gauge</strong>:</p><div class="unfoldcb9b593a-64b2-11e7-aa61-a820660f017d"></div>End of <strong>fix_A_new_gauge_update_to_gauge</strong></blockquote></div>End of <strong>fix_A_new_gauge</strong></blockquote>Put A_new,new_log_fact to return value<br><p class="param_use">return_pieces is true, put A_part_list,u,v,w,B,BUS,BSV,z into return value</p><p class="param_use">return_gauges & horz_refl true, then optimize_G_hv</p><blockquote><p class="foldcb9cafb0-64b2-11e7-ac88-a820660f017d">Beginning of <strong>optimize_G_hv</strong>:</p><div class="unfoldcb9cafb0-64b2-11e7-ac88-a820660f017d"><blockquote><p class="foldcb9d20e4-64b2-11e7-a437-a820660f017d">Beginning of <strong>while loop under cost_change > 1e-11 and counter < 10000</strong>:</p><div class="unfoldcb9d20e4-64b2-11e7-a437-a820660f017d"></div>End of <strong>while loop</strong></blockquote><log>After 3 iterations, error in optimize_G_hv is 1.355e-14.</log><br/><log><em>G_hv</em> has shape: [[5, 5], [5, 5]]</log><br/></div>End of <strong>optimize_G_hv</strong></blockquote><blockquote><p class="foldcb9fbf22-64b2-11e7-9598-a820660f017d">Beginning of <strong>optimize_G_vh</strong>:</p><div class="unfoldcb9fbf22-64b2-11e7-9598-a820660f017d"><blockquote><p class="foldcb9fd514-64b2-11e7-a47d-a820660f017d">Beginning of <strong>while loop under cost_change > 1e-11 and counter < 10000</strong>:</p><div class="unfoldcb9fd514-64b2-11e7-a47d-a820660f017d"></div>End of <strong>while loop</strong></blockquote><log>After 3 iterations, error in optimize_G_vh is 3.085e-15.</log><br/><log><em>G_vh</em> has shape: [[5, 5], [5, 5]]</log><br/></div>End of <strong>optimize_G_vh</strong></blockquote>put G_hh,G_hv,G_vh into return value</div>End of <strong>TNR_step</strong></blockquote></div>End of <strong>generate_next_tensor</strong></blockquote></div>End of <strong>generate_tensor</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_tensor</strong></blockquote><blockquote><p class="foldcba40aa8-64b2-11e7-af65-a820660f017d">Beginning of <strong>get_tensor</strong>:</p><div class="unfoldcba40aa8-64b2-11e7-af65-a820660f017d"><blockquote><p class="foldcba40e10-64b2-11e7-935f-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfoldcba40e10-64b2-11e7-935f-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="foldcba410c0-64b2-11e7-8fa4-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfoldcba410c0-64b2-11e7-8fa4-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote><blockquote><p class="foldcba418b8-64b2-11e7-a30f-a820660f017d">Beginning of <strong>generate_tensor</strong>:</p><div class="unfoldcba418b8-64b2-11e7-a30f-a820660f017d"><blockquote><p class="foldcba41b06-64b2-11e7-ae81-a820660f017d">Beginning of <strong>generate_next_tensor</strong>:</p><div class="unfoldcba41b06-64b2-11e7-ae81-a820660f017d"><blockquote><p class="foldcba41d2c-64b2-11e7-8964-a820660f017d">Beginning of <strong>get_tensor</strong>:</p><div class="unfoldcba41d2c-64b2-11e7-8964-a820660f017d"><blockquote><p class="foldcba41fa2-64b2-11e7-a198-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfoldcba41fa2-64b2-11e7-a198-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="foldcba421dc-64b2-11e7-8f22-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfoldcba421dc-64b2-11e7-8f22-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_tensor</strong></blockquote> Coarse-graining, iter_count = #5: / <br/><blockquote><p class="foldcba43828-64b2-11e7-a736-a820660f017d">Beginning of <strong>get_gauges</strong>:</p><div class="unfoldcba43828-64b2-11e7-a736-a820660f017d"><blockquote><p class="foldcba43c08-64b2-11e7-9eed-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfoldcba43c08-64b2-11e7-9eed-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="foldcba43f50-64b2-11e7-b7c0-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfoldcba43f50-64b2-11e7-b7c0-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_gauges</strong></blockquote><blockquote><p class="foldcba4506c-64b2-11e7-8f31-a820660f017d">Beginning of <strong>get_pieces</strong>:</p><div class="unfoldcba4506c-64b2-11e7-8f31-a820660f017d"><blockquote><p class="foldcba45364-64b2-11e7-9350-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfoldcba45364-64b2-11e7-9350-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="foldcba4561e-64b2-11e7-ac5a-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfoldcba4561e-64b2-11e7-ac5a-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_pieces</strong></blockquote><blockquote><p class="foldcba47f08-64b2-11e7-9b4c-a820660f017d">Beginning of <strong>TNR_step</strong>:</p><div class="unfoldcba47f08-64b2-11e7-9b4c-a820660f017d">The function <strong>format_parameters</strong> formats some of the parameters given to <em>tnr_step</em> to a canonical form.<br/><ul>
    <li>Make sure <em>A_list</em> is a list of 2 tensors</li>
    <li>Create pars, gauges and pieces.</li>
    <li>Values are taken primarily from kwargs, then from pars, gauges and pieces, and finally from default. Only ones listed in defaults are used, others are ignored.</li>
    <li>Make sure <em>chis_tnr</em> and <em>chis_trg</em> are a lists of integers (or at least singlet lists of one integer) and sorted from small to large.</li>
    <li>If several chis to loop over are given but there is no epsilon to determine sufficient accuracy, then just use the largest chi.</li>
    </ul><blockquote><p class="foldcba4856e-64b2-11e7-ab8a-a820660f017d">Beginning of <strong>symmetrize_A_list</strong>:</p><div class="unfoldcba4856e-64b2-11e7-ab8a-a820660f017d"> Symmetrizes <em>A_list</em> according to the value of <em>horz_refl</em>. <br/><p class="param_use"><em>horz_relf</em> is true, transpose A[0] to get A[1]</p></div>End of <strong>symmetrize_A_list</strong></blockquote><blockquote><p class="foldcba51466-64b2-11e7-bc42-a820660f017d">Beginning of <strong>split_A_list</strong>:</p><div class="unfoldcba51466-64b2-11e7-bc42-a820660f017d"> SVDs the tensors in A_list and returns a list of lists with the parts in them. See split_A for details.<br/><blockquote><p class="foldcba51bf0-64b2-11e7-ab96-a820660f017d">Beginning of <strong>split_A</strong>:</p><div class="unfoldcba51bf0-64b2-11e7-ab96-a820660f017d"><log>Shape of A is[[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/> <br/>Splits an A tensor by SVD into two. eps is the tolerance in the
    SVD, <em>chis</em> is the list of bond dimensions to try when splitting (by
    default the full possible range is tried) and direction specifies
    the way to split.  If direction == 'nesw' (case and space
    insensitive) the splitting is done so that the northeast and
    southwest components are created, and similarly for direction ==
    'nwse'. For all other values of direction both splittings are done.
    The values are returned in the order A_NW, A_SE, A_NE, A_SW,
    possibly leaving out some based on direction.<br/>
    <br/><log>Split A NWSE with chi=36</log><br/><log>split A in NWSE direction,bond dimensions are like:<br/>A_NW:[[5, 5], [5, 5], [18, 18]]<br/>A_SE:[[18, 18], [5, 5], [5, 5]]<br/></log>The final result of split_A is a list, of which the elements are like A_NW,..., and each element has three external legs.<br/></div>End of <strong>split_A</strong></blockquote><blockquote><p class="foldcba607a4-64b2-11e7-8cfa-a820660f017d">Beginning of <strong>split_A</strong>:</p><div class="unfoldcba607a4-64b2-11e7-8cfa-a820660f017d"><log>Shape of A is[[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/> <br/>Splits an A tensor by SVD into two. eps is the tolerance in the
    SVD, <em>chis</em> is the list of bond dimensions to try when splitting (by
    default the full possible range is tried) and direction specifies
    the way to split.  If direction == 'nesw' (case and space
    insensitive) the splitting is done so that the northeast and
    southwest components are created, and similarly for direction ==
    'nwse'. For all other values of direction both splittings are done.
    The values are returned in the order A_NW, A_SE, A_NE, A_SW,
    possibly leaving out some based on direction.<br/>
    <log>Split A NESW with chi=36<br/>split A in NESW direction,bond dimensions are like:<br/>A_NE:[[5, 5], [5, 5], [18, 18]]<br/>A_SW:[[5, 5], [18, 18], [5, 5]]</log><br/>The final result of split_A is a list, of which the elements are like A_NW,..., and each element has three external legs.<br/></div>End of <strong>split_A</strong></blockquote>A_part_list = [split(A[0],nwse),split(A[1],nesw)]<br/>A_part_list[0]=split(A0,nwse)<br/>A_part_list[1]=split(A1,nesw)<br/>A_part_list[0][0]=A_NW<br/>A_part_list[0][1]=A_SE<br/>A_part_list[1][0]=A_NE<br/>A_part_list[1][1]=A_SW</div>End of <strong>split_A_list</strong></blockquote> store the result of <strong>split_A_list</strong> to <em>A_part_list</em><br/>
    A_part_list in only used in upb when pars[use_part] is true, otherwise this A_part_list is never used.<br>
     use SVDed A if chi_split < chi_orig**(3/2)<br/>calculate <em>chi_orig</em> and <em>chi_split</em> from <em>A_NW</em>,then determine whether to use the SVD of the original tensor, based on a rough estimate of whether it's computationally advantageous.<iptt>pars["use_parts"] = chi_split < chi_orig**(3/2)</iptt>Not using the SVDed A.<br/><br/>Obtain the optimized <em>u,v,w</em>.<br/><blockquote><p class="foldcba6bed0-64b2-11e7-b062-a820660f017d">Beginning of <strong>build_uvw</strong>:</p><div class="unfoldcba6bed0-64b2-11e7-b062-a820660f017d">This function optimize the u,v_R,v_L independently(linearly) as in the paper.<br/>Loop over growing truncation dimensions until the truncation error is small enough.<br/><br/> recall that chi_prime < chi^2, so the truncation dimension grows from chi to chi_prime after one TNR step<br/><blockquote><p class="foldcba7e4ca-64b2-11e7-b233-a820660f017d">Beginning of <strong>for loop</strong>:</p><div class="unfoldcba7e4ca-64b2-11e7-b233-a820660f017d"><pre>for <em>chi_num, chi</em> in enumerate(pars["chis_tnr"]):</pre><br/>loop over <em>chis_tnr</em> the bond dimension<br/><enumerate object at 0x10d828ee8><br/>Optimizing for chi = 6.<br/><blockquote><p class="foldcba7eb0a-64b2-11e7-84f3-a820660f017d">Beginning of <strong>initial_uvw</strong>:</p><div class="unfoldcba7eb0a-64b2-11e7-84f3-a820660f017d"> Returns the initial disentangler and isometries that are the starting point of the optimization. The initial u is the identity, the initial isometries are SVDed from A just like in TRG, truncated to dimension chi.<br/><br/><log>initial u has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/><log>initial v has shape: [[5, 5], [3, 3], [5, 5]]</log><br/><log>initial w has shape: [[3, 3], [5, 5], [5, 5]]</log><br/></div>End of <strong>initial_uvw</strong></blockquote>there is <iptt>a while loop in this for loop</iptt> to optimize u,v,w<br/><pre>while (cost_change > pars["opt_eps_conv"] and counter < pars["opt_max_iter"]):
                counter += 1
                old_cost = new_cost
                v, w = <strong>optimize_isometries</strong>(u, v, w, A_list, A_part_list, pars, gauges)
                u, B_norm = <strong>optimize_disentangler</strong>(u, v, w, A_list, A_part_list, pars, return_B_norm=True)</pre><br/> keep optimizing u,v,w iteratively to <iptt>maximize the norm of B</iptt> until the relative change is less than <em>opt_eps_conv</em>. if convergence is not reached in <em>opt_max_iter</em> steps, stop and move on</div>End of <strong>for loop</strong></blockquote><log>Truncated bond dimension in TNR: 6</log><br/><log>Optimization converged after 15 iterations.</log><br/><log>Relative error in optimized, truncated TNR block is: 1.366e-03 + 0j</log><br/><log>u has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/><log>v has shape: [[5, 5], [3, 3], [5, 5]]</log><br/><log>w has shape: [[3, 3], [5, 5], [5, 5]]</log><br/></div>End of <strong>build_uvw</strong></blockquote>Build the intermediate tensors <em>B</em> and <em>z</em> and use them to derive <em>A_new</em>.<br/><blockquote><p class="foldcc390c14-64b2-11e7-af45-a820660f017d">Beginning of <strong>build_B</strong>:</p><div class="unfoldcc390c14-64b2-11e7-af45-a820660f017d"></div>End of <strong>build_B</strong></blockquote>This step is very simple, since <em>upb</em> (the upper half of B) is totally determined by <em>u,v,w</em> and <em>A</em>, just contract <em>upb</em> with upb^dagger<br/><br/><log>before splitting B has shape: [[3, 3], [3, 3], [3, 3], [3, 3]]</log><br/><blockquote><p class="foldcc3aa378-64b2-11e7-bd49-a820660f017d">Beginning of <strong>split_B</strong>:</p><div class="unfoldcc3aa378-64b2-11e7-bd49-a820660f017d">no optimization in split_B, just take out the SVDed value<br/><log>The splitting result has shape:<br/>US (should be U*sqrt(S) ): [[3, 3], [5, 5], [3, 3]]<br/>SV (should be sqrt(S)*V ): [[5, 5], [3, 3], [3, 3]]<br/></log><log>Truncated bond dimension in split_B: 10</log><br/></div>End of <strong>split_B</strong></blockquote>split B horizontally, BUS,BSV = B.svd((0,3), (1,2))<br/>obtain <em>BUS, BSV</em> from <strong>split_B</strong>.<br/> <div class="codeblock">splitting B with chis=chis_trg</div><p class="param_use"><em>return_gauges</em> is true, then derive <em>G_hh</em> from <strong>split_B</strong></p><blockquote><p class="foldcc3b431e-64b2-11e7-a11e-a820660f017d">Beginning of <strong>build_z</strong>:</p><div class="unfoldcc3b431e-64b2-11e7-a11e-a820660f017d">also no optimization in build_z, calculate the environment <em>M</em> and SVD it.<br/><log>the environment of z has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/><log>z has shape: [[5, 5], [5, 5], [5, 5]]</log><br/><log>Truncated bond dimension in build_z: 10</log><br/></div>End of <strong>build_z</strong></blockquote>mapping from the parameters used here to that used in the paper'algorithms in TNR'
    <pre>
    u ---> u
    w ---> v_L
    v ---> v_R
    z ---> w
    </pre>
    <blockquote><p class="foldcc3d92f6-64b2-11e7-ac51-a820660f017d">Beginning of <strong>build_A_new</strong>:</p><div class="unfoldcc3d92f6-64b2-11e7-ac51-a820660f017d"><log><em>A_new</em> has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/></div>End of <strong>build_A_new</strong></blockquote>Scale A_new to have largest values around unity and use that to update new_log_fact.<br/>normalize <em>A_new</em> to have unit norm<br><iptt>new_log_fact = np.log(fact) + 4*log_fact</iptt>, here <em>fact</em> is the original norm of <em>A_new</em>, <em>log_fact is inherited from pars[...]</em><br/>obtain renewed <strong>A_new,BUS,BSV,z</strong> from <strong>fix_A_new_gauge</strong><p class="param_use"><br/>also obtain G_hh if "return_gauges" is true</p><blockquote><p class="foldcc3ed966-64b2-11e7-86ec-a820660f017d">Beginning of <strong>fix_A_new_gauge</strong>:</p><div class="unfoldcc3ed966-64b2-11e7-86ec-a820660f017d"><blockquote><p class="foldcc3f39f6-64b2-11e7-b435-a820660f017d">Beginning of <strong>while loop under cost_change > 1e-11 and counter < 10000</strong>:</p><div class="unfoldcc3f39f6-64b2-11e7-b435-a820660f017d"><blockquote><p class="foldcc3f3d0c-64b2-11e7-8d41-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldcc3f3d0c-64b2-11e7-8d41-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldcc4082d4-64b2-11e7-b5fb-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldcc4082d4-64b2-11e7-b5fb-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote><blockquote><p class="foldcc417a88-64b2-11e7-8d78-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldcc417a88-64b2-11e7-8d78-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldcc429d26-64b2-11e7-b7bc-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldcc429d26-64b2-11e7-b7bc-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote><blockquote><p class="foldcc43a630-64b2-11e7-a9f7-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldcc43a630-64b2-11e7-a9f7-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldcc44be62-64b2-11e7-bebd-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldcc44be62-64b2-11e7-bebd-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote><blockquote><p class="foldcc45fe08-64b2-11e7-8b4d-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldcc45fe08-64b2-11e7-8b4d-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldcc46d53a-64b2-11e7-a2b7-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldcc46d53a-64b2-11e7-a2b7-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote></div>End of <strong>while loop</strong></blockquote><blockquote><p class="foldcc47f2a8-64b2-11e7-9508-a820660f017d">Beginning of <strong>fix_A_new_gauge_update_to_gauge</strong>:</p><div class="unfoldcc47f2a8-64b2-11e7-9508-a820660f017d"></div>End of <strong>fix_A_new_gauge_update_to_gauge</strong></blockquote></div>End of <strong>fix_A_new_gauge</strong></blockquote>Put A_new,new_log_fact to return value<br><p class="param_use">return_pieces is true, put A_part_list,u,v,w,B,BUS,BSV,z into return value</p><p class="param_use">return_gauges & horz_refl true, then optimize_G_hv</p><blockquote><p class="foldcc493cba-64b2-11e7-afe7-a820660f017d">Beginning of <strong>optimize_G_hv</strong>:</p><div class="unfoldcc493cba-64b2-11e7-afe7-a820660f017d"><blockquote><p class="foldcc49ab66-64b2-11e7-84b9-a820660f017d">Beginning of <strong>while loop under cost_change > 1e-11 and counter < 10000</strong>:</p><div class="unfoldcc49ab66-64b2-11e7-84b9-a820660f017d"></div>End of <strong>while loop</strong></blockquote><log>After 3 iterations, error in optimize_G_hv is 1.655e-14.</log><br/><log><em>G_hv</em> has shape: [[5, 5], [5, 5]]</log><br/></div>End of <strong>optimize_G_hv</strong></blockquote><blockquote><p class="foldcc4c8c78-64b2-11e7-a2a4-a820660f017d">Beginning of <strong>optimize_G_vh</strong>:</p><div class="unfoldcc4c8c78-64b2-11e7-a2a4-a820660f017d"><blockquote><p class="foldcc4ca3ae-64b2-11e7-8f48-a820660f017d">Beginning of <strong>while loop under cost_change > 1e-11 and counter < 10000</strong>:</p><div class="unfoldcc4ca3ae-64b2-11e7-8f48-a820660f017d"></div>End of <strong>while loop</strong></blockquote><log>After 3 iterations, error in optimize_G_vh is 3.211e-15.</log><br/><log><em>G_vh</em> has shape: [[5, 5], [5, 5]]</log><br/></div>End of <strong>optimize_G_vh</strong></blockquote>put G_hh,G_hv,G_vh into return value</div>End of <strong>TNR_step</strong></blockquote></div>End of <strong>generate_next_tensor</strong></blockquote></div>End of <strong>generate_tensor</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_tensor</strong></blockquote><blockquote><p class="foldcc5038ac-64b2-11e7-bf1f-a820660f017d">Beginning of <strong>get_tensor</strong>:</p><div class="unfoldcc5038ac-64b2-11e7-bf1f-a820660f017d"><blockquote><p class="foldcc503c42-64b2-11e7-93ed-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfoldcc503c42-64b2-11e7-93ed-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="foldcc503f62-64b2-11e7-baab-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfoldcc503f62-64b2-11e7-baab-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote><blockquote><p class="foldcc50478c-64b2-11e7-8470-a820660f017d">Beginning of <strong>generate_tensor</strong>:</p><div class="unfoldcc50478c-64b2-11e7-8470-a820660f017d"><blockquote><p class="foldcc504a86-64b2-11e7-9f8c-a820660f017d">Beginning of <strong>generate_next_tensor</strong>:</p><div class="unfoldcc504a86-64b2-11e7-9f8c-a820660f017d"><blockquote><p class="foldcc504d36-64b2-11e7-a1a4-a820660f017d">Beginning of <strong>get_tensor</strong>:</p><div class="unfoldcc504d36-64b2-11e7-a1a4-a820660f017d"><blockquote><p class="foldcc504f70-64b2-11e7-b539-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfoldcc504f70-64b2-11e7-b539-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="foldcc50525e-64b2-11e7-a6c1-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfoldcc50525e-64b2-11e7-a6c1-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_tensor</strong></blockquote> Coarse-graining, iter_count = #6: / <br/><blockquote><p class="foldcc5069c2-64b2-11e7-a6e1-a820660f017d">Beginning of <strong>get_gauges</strong>:</p><div class="unfoldcc5069c2-64b2-11e7-a6e1-a820660f017d"><blockquote><p class="foldcc506ef6-64b2-11e7-9411-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfoldcc506ef6-64b2-11e7-9411-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="foldcc5072ca-64b2-11e7-98b6-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfoldcc5072ca-64b2-11e7-98b6-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_gauges</strong></blockquote><blockquote><p class="foldcc50849c-64b2-11e7-8260-a820660f017d">Beginning of <strong>get_pieces</strong>:</p><div class="unfoldcc50849c-64b2-11e7-8260-a820660f017d"><blockquote><p class="foldcc50885a-64b2-11e7-8c55-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfoldcc50885a-64b2-11e7-8c55-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="foldcc508b0c-64b2-11e7-bb3d-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfoldcc508b0c-64b2-11e7-bb3d-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_pieces</strong></blockquote><blockquote><p class="foldcc50b458-64b2-11e7-b1d3-a820660f017d">Beginning of <strong>TNR_step</strong>:</p><div class="unfoldcc50b458-64b2-11e7-b1d3-a820660f017d">The function <strong>format_parameters</strong> formats some of the parameters given to <em>tnr_step</em> to a canonical form.<br/><ul>
    <li>Make sure <em>A_list</em> is a list of 2 tensors</li>
    <li>Create pars, gauges and pieces.</li>
    <li>Values are taken primarily from kwargs, then from pars, gauges and pieces, and finally from default. Only ones listed in defaults are used, others are ignored.</li>
    <li>Make sure <em>chis_tnr</em> and <em>chis_trg</em> are a lists of integers (or at least singlet lists of one integer) and sorted from small to large.</li>
    <li>If several chis to loop over are given but there is no epsilon to determine sufficient accuracy, then just use the largest chi.</li>
    </ul><blockquote><p class="foldcc50bd5c-64b2-11e7-871e-a820660f017d">Beginning of <strong>symmetrize_A_list</strong>:</p><div class="unfoldcc50bd5c-64b2-11e7-871e-a820660f017d"> Symmetrizes <em>A_list</em> according to the value of <em>horz_refl</em>. <br/><p class="param_use"><em>horz_relf</em> is true, transpose A[0] to get A[1]</p></div>End of <strong>symmetrize_A_list</strong></blockquote><blockquote><p class="foldcc5129ae-64b2-11e7-8cf2-a820660f017d">Beginning of <strong>split_A_list</strong>:</p><div class="unfoldcc5129ae-64b2-11e7-8cf2-a820660f017d"> SVDs the tensors in A_list and returns a list of lists with the parts in them. See split_A for details.<br/><blockquote><p class="foldcc512ff8-64b2-11e7-a213-a820660f017d">Beginning of <strong>split_A</strong>:</p><div class="unfoldcc512ff8-64b2-11e7-a213-a820660f017d"><log>Shape of A is[[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/> <br/>Splits an A tensor by SVD into two. eps is the tolerance in the
    SVD, <em>chis</em> is the list of bond dimensions to try when splitting (by
    default the full possible range is tried) and direction specifies
    the way to split.  If direction == 'nesw' (case and space
    insensitive) the splitting is done so that the northeast and
    southwest components are created, and similarly for direction ==
    'nwse'. For all other values of direction both splittings are done.
    The values are returned in the order A_NW, A_SE, A_NE, A_SW,
    possibly leaving out some based on direction.<br/>
    <br/><log>Split A NWSE with chi=36</log><br/><log>split A in NWSE direction,bond dimensions are like:<br/>A_NW:[[5, 5], [5, 5], [18, 18]]<br/>A_SE:[[18, 18], [5, 5], [5, 5]]<br/></log>The final result of split_A is a list, of which the elements are like A_NW,..., and each element has three external legs.<br/></div>End of <strong>split_A</strong></blockquote><blockquote><p class="foldcc52366e-64b2-11e7-bee2-a820660f017d">Beginning of <strong>split_A</strong>:</p><div class="unfoldcc52366e-64b2-11e7-bee2-a820660f017d"><log>Shape of A is[[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/> <br/>Splits an A tensor by SVD into two. eps is the tolerance in the
    SVD, <em>chis</em> is the list of bond dimensions to try when splitting (by
    default the full possible range is tried) and direction specifies
    the way to split.  If direction == 'nesw' (case and space
    insensitive) the splitting is done so that the northeast and
    southwest components are created, and similarly for direction ==
    'nwse'. For all other values of direction both splittings are done.
    The values are returned in the order A_NW, A_SE, A_NE, A_SW,
    possibly leaving out some based on direction.<br/>
    <log>Split A NESW with chi=36<br/>split A in NESW direction,bond dimensions are like:<br/>A_NE:[[5, 5], [5, 5], [18, 18]]<br/>A_SW:[[5, 5], [18, 18], [5, 5]]</log><br/>The final result of split_A is a list, of which the elements are like A_NW,..., and each element has three external legs.<br/></div>End of <strong>split_A</strong></blockquote>A_part_list = [split(A[0],nwse),split(A[1],nesw)]<br/>A_part_list[0]=split(A0,nwse)<br/>A_part_list[1]=split(A1,nesw)<br/>A_part_list[0][0]=A_NW<br/>A_part_list[0][1]=A_SE<br/>A_part_list[1][0]=A_NE<br/>A_part_list[1][1]=A_SW</div>End of <strong>split_A_list</strong></blockquote> store the result of <strong>split_A_list</strong> to <em>A_part_list</em><br/>
    A_part_list in only used in upb when pars[use_part] is true, otherwise this A_part_list is never used.<br>
     use SVDed A if chi_split < chi_orig**(3/2)<br/>calculate <em>chi_orig</em> and <em>chi_split</em> from <em>A_NW</em>,then determine whether to use the SVD of the original tensor, based on a rough estimate of whether it's computationally advantageous.<iptt>pars["use_parts"] = chi_split < chi_orig**(3/2)</iptt>Not using the SVDed A.<br/><br/>Obtain the optimized <em>u,v,w</em>.<br/><blockquote><p class="foldcc52f090-64b2-11e7-b4a5-a820660f017d">Beginning of <strong>build_uvw</strong>:</p><div class="unfoldcc52f090-64b2-11e7-b4a5-a820660f017d">This function optimize the u,v_R,v_L independently(linearly) as in the paper.<br/>Loop over growing truncation dimensions until the truncation error is small enough.<br/><br/> recall that chi_prime < chi^2, so the truncation dimension grows from chi to chi_prime after one TNR step<br/><blockquote><p class="foldcc53e312-64b2-11e7-92c7-a820660f017d">Beginning of <strong>for loop</strong>:</p><div class="unfoldcc53e312-64b2-11e7-92c7-a820660f017d"><pre>for <em>chi_num, chi</em> in enumerate(pars["chis_tnr"]):</pre><br/>loop over <em>chis_tnr</em> the bond dimension<br/><enumerate object at 0x10d834798><br/>Optimizing for chi = 6.<br/><blockquote><p class="foldcc53e99e-64b2-11e7-97d5-a820660f017d">Beginning of <strong>initial_uvw</strong>:</p><div class="unfoldcc53e99e-64b2-11e7-97d5-a820660f017d"> Returns the initial disentangler and isometries that are the starting point of the optimization. The initial u is the identity, the initial isometries are SVDed from A just like in TRG, truncated to dimension chi.<br/><br/><log>initial u has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/><log>initial v has shape: [[5, 5], [3, 3], [5, 5]]</log><br/><log>initial w has shape: [[3, 3], [5, 5], [5, 5]]</log><br/></div>End of <strong>initial_uvw</strong></blockquote>there is <iptt>a while loop in this for loop</iptt> to optimize u,v,w<br/><pre>while (cost_change > pars["opt_eps_conv"] and counter < pars["opt_max_iter"]):
                counter += 1
                old_cost = new_cost
                v, w = <strong>optimize_isometries</strong>(u, v, w, A_list, A_part_list, pars, gauges)
                u, B_norm = <strong>optimize_disentangler</strong>(u, v, w, A_list, A_part_list, pars, return_B_norm=True)</pre><br/> keep optimizing u,v,w iteratively to <iptt>maximize the norm of B</iptt> until the relative change is less than <em>opt_eps_conv</em>. if convergence is not reached in <em>opt_max_iter</em> steps, stop and move on</div>End of <strong>for loop</strong></blockquote><log>Truncated bond dimension in TNR: 6</log><br/><log>Optimization converged after 11 iterations.</log><br/><log>Relative error in optimized, truncated TNR block is: 1.372e-03 + 0j</log><br/><log>u has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/><log>v has shape: [[5, 5], [3, 3], [5, 5]]</log><br/><log>w has shape: [[3, 3], [5, 5], [5, 5]]</log><br/></div>End of <strong>build_uvw</strong></blockquote>Build the intermediate tensors <em>B</em> and <em>z</em> and use them to derive <em>A_new</em>.<br/><blockquote><p class="foldccbd91fe-64b2-11e7-9d3a-a820660f017d">Beginning of <strong>build_B</strong>:</p><div class="unfoldccbd91fe-64b2-11e7-9d3a-a820660f017d"></div>End of <strong>build_B</strong></blockquote>This step is very simple, since <em>upb</em> (the upper half of B) is totally determined by <em>u,v,w</em> and <em>A</em>, just contract <em>upb</em> with upb^dagger<br/><br/><log>before splitting B has shape: [[3, 3], [3, 3], [3, 3], [3, 3]]</log><br/><blockquote><p class="foldccbf5a00-64b2-11e7-a135-a820660f017d">Beginning of <strong>split_B</strong>:</p><div class="unfoldccbf5a00-64b2-11e7-a135-a820660f017d">no optimization in split_B, just take out the SVDed value<br/><log>The splitting result has shape:<br/>US (should be U*sqrt(S) ): [[3, 3], [5, 5], [3, 3]]<br/>SV (should be sqrt(S)*V ): [[5, 5], [3, 3], [3, 3]]<br/></log><log>Truncated bond dimension in split_B: 10</log><br/></div>End of <strong>split_B</strong></blockquote>split B horizontally, BUS,BSV = B.svd((0,3), (1,2))<br/>obtain <em>BUS, BSV</em> from <strong>split_B</strong>.<br/> <div class="codeblock">splitting B with chis=chis_trg</div><p class="param_use"><em>return_gauges</em> is true, then derive <em>G_hh</em> from <strong>split_B</strong></p><blockquote><p class="foldccbfc8da-64b2-11e7-9c10-a820660f017d">Beginning of <strong>build_z</strong>:</p><div class="unfoldccbfc8da-64b2-11e7-9c10-a820660f017d">also no optimization in build_z, calculate the environment <em>M</em> and SVD it.<br/><log>the environment of z has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/><log>z has shape: [[5, 5], [5, 5], [5, 5]]</log><br/><log>Truncated bond dimension in build_z: 10</log><br/></div>End of <strong>build_z</strong></blockquote>mapping from the parameters used here to that used in the paper'algorithms in TNR'
    <pre>
    u ---> u
    w ---> v_L
    v ---> v_R
    z ---> w
    </pre>
    <blockquote><p class="foldccc244f6-64b2-11e7-aeeb-a820660f017d">Beginning of <strong>build_A_new</strong>:</p><div class="unfoldccc244f6-64b2-11e7-aeeb-a820660f017d"><log><em>A_new</em> has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/></div>End of <strong>build_A_new</strong></blockquote>Scale A_new to have largest values around unity and use that to update new_log_fact.<br/>normalize <em>A_new</em> to have unit norm<br><iptt>new_log_fact = np.log(fact) + 4*log_fact</iptt>, here <em>fact</em> is the original norm of <em>A_new</em>, <em>log_fact is inherited from pars[...]</em><br/>obtain renewed <strong>A_new,BUS,BSV,z</strong> from <strong>fix_A_new_gauge</strong><p class="param_use"><br/>also obtain G_hh if "return_gauges" is true</p><blockquote><p class="foldccc38490-64b2-11e7-8f50-a820660f017d">Beginning of <strong>fix_A_new_gauge</strong>:</p><div class="unfoldccc38490-64b2-11e7-8f50-a820660f017d"><blockquote><p class="foldccc41688-64b2-11e7-bc81-a820660f017d">Beginning of <strong>while loop under cost_change > 1e-11 and counter < 10000</strong>:</p><div class="unfoldccc41688-64b2-11e7-bc81-a820660f017d"><blockquote><p class="foldccc41a4a-64b2-11e7-a287-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldccc41a4a-64b2-11e7-a287-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldccc51a42-64b2-11e7-85b0-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldccc51a42-64b2-11e7-85b0-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote><blockquote><p class="foldccc60954-64b2-11e7-ac19-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldccc60954-64b2-11e7-ac19-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldccc71a88-64b2-11e7-8af0-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldccc71a88-64b2-11e7-8af0-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote><blockquote><p class="foldccc81492-64b2-11e7-91f6-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldccc81492-64b2-11e7-91f6-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldccc97300-64b2-11e7-8fef-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldccc97300-64b2-11e7-8fef-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote><blockquote><p class="foldccca66ca-64b2-11e7-9a16-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldccca66ca-64b2-11e7-9a16-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldcccb8bd8-64b2-11e7-bf31-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldcccb8bd8-64b2-11e7-bf31-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote><blockquote><p class="foldccccbdd2-64b2-11e7-a874-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldccccbdd2-64b2-11e7-a874-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldcccda206-64b2-11e7-9a81-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldcccda206-64b2-11e7-9a81-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote></div>End of <strong>while loop</strong></blockquote><blockquote><p class="foldccceecec-64b2-11e7-9e11-a820660f017d">Beginning of <strong>fix_A_new_gauge_update_to_gauge</strong>:</p><div class="unfoldccceecec-64b2-11e7-9e11-a820660f017d"></div>End of <strong>fix_A_new_gauge_update_to_gauge</strong></blockquote></div>End of <strong>fix_A_new_gauge</strong></blockquote>Put A_new,new_log_fact to return value<br><p class="param_use">return_pieces is true, put A_part_list,u,v,w,B,BUS,BSV,z into return value</p><p class="param_use">return_gauges & horz_refl true, then optimize_G_hv</p><blockquote><p class="foldccd0c202-64b2-11e7-bb6e-a820660f017d">Beginning of <strong>optimize_G_hv</strong>:</p><div class="unfoldccd0c202-64b2-11e7-bb6e-a820660f017d"><blockquote><p class="foldccd15070-64b2-11e7-ad8f-a820660f017d">Beginning of <strong>while loop under cost_change > 1e-11 and counter < 10000</strong>:</p><div class="unfoldccd15070-64b2-11e7-ad8f-a820660f017d"></div>End of <strong>while loop</strong></blockquote><log>After 3 iterations, error in optimize_G_hv is 1.842e-14.</log><br/><log><em>G_hv</em> has shape: [[5, 5], [5, 5]]</log><br/></div>End of <strong>optimize_G_hv</strong></blockquote><blockquote><p class="foldccd44bde-64b2-11e7-8109-a820660f017d">Beginning of <strong>optimize_G_vh</strong>:</p><div class="unfoldccd44bde-64b2-11e7-8109-a820660f017d"><blockquote><p class="foldccd465a6-64b2-11e7-abce-a820660f017d">Beginning of <strong>while loop under cost_change > 1e-11 and counter < 10000</strong>:</p><div class="unfoldccd465a6-64b2-11e7-abce-a820660f017d"></div>End of <strong>while loop</strong></blockquote><log>After 3 iterations, error in optimize_G_vh is 1.527e-15.</log><br/><log><em>G_vh</em> has shape: [[5, 5], [5, 5]]</log><br/></div>End of <strong>optimize_G_vh</strong></blockquote>put G_hh,G_hv,G_vh into return value</div>End of <strong>TNR_step</strong></blockquote></div>End of <strong>generate_next_tensor</strong></blockquote></div>End of <strong>generate_tensor</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_tensor</strong></blockquote><blockquote><p class="foldccd8a6b6-64b2-11e7-9e54-a820660f017d">Beginning of <strong>get_tensor</strong>:</p><div class="unfoldccd8a6b6-64b2-11e7-9e54-a820660f017d"><blockquote><p class="foldccd8add4-64b2-11e7-aa5a-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfoldccd8add4-64b2-11e7-aa5a-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="foldccd8b1e4-64b2-11e7-ba86-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfoldccd8b1e4-64b2-11e7-ba86-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote><blockquote><p class="foldccd8bd24-64b2-11e7-bfa8-a820660f017d">Beginning of <strong>generate_tensor</strong>:</p><div class="unfoldccd8bd24-64b2-11e7-bfa8-a820660f017d"><blockquote><p class="foldccd8c026-64b2-11e7-84de-a820660f017d">Beginning of <strong>generate_next_tensor</strong>:</p><div class="unfoldccd8c026-64b2-11e7-84de-a820660f017d"><blockquote><p class="foldccd8c55a-64b2-11e7-b985-a820660f017d">Beginning of <strong>get_tensor</strong>:</p><div class="unfoldccd8c55a-64b2-11e7-b985-a820660f017d"><blockquote><p class="foldccd8c94a-64b2-11e7-9b5e-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfoldccd8c94a-64b2-11e7-9b5e-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="foldccd8cdb4-64b2-11e7-a744-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfoldccd8cdb4-64b2-11e7-a744-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_tensor</strong></blockquote> Coarse-graining, iter_count = #7: / <br/><blockquote><p class="foldccd8e7c2-64b2-11e7-b89b-a820660f017d">Beginning of <strong>get_gauges</strong>:</p><div class="unfoldccd8e7c2-64b2-11e7-b89b-a820660f017d"><blockquote><p class="foldccd8ee34-64b2-11e7-972c-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfoldccd8ee34-64b2-11e7-972c-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="foldccd8f1de-64b2-11e7-a815-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfoldccd8f1de-64b2-11e7-a815-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_gauges</strong></blockquote><blockquote><p class="foldccd9035e-64b2-11e7-ae1a-a820660f017d">Beginning of <strong>get_pieces</strong>:</p><div class="unfoldccd9035e-64b2-11e7-ae1a-a820660f017d"><blockquote><p class="foldccd9068a-64b2-11e7-aa57-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfoldccd9068a-64b2-11e7-aa57-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="foldccd90a10-64b2-11e7-9792-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfoldccd90a10-64b2-11e7-9792-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_pieces</strong></blockquote><blockquote><p class="foldccd93164-64b2-11e7-b110-a820660f017d">Beginning of <strong>TNR_step</strong>:</p><div class="unfoldccd93164-64b2-11e7-b110-a820660f017d">The function <strong>format_parameters</strong> formats some of the parameters given to <em>tnr_step</em> to a canonical form.<br/><ul>
    <li>Make sure <em>A_list</em> is a list of 2 tensors</li>
    <li>Create pars, gauges and pieces.</li>
    <li>Values are taken primarily from kwargs, then from pars, gauges and pieces, and finally from default. Only ones listed in defaults are used, others are ignored.</li>
    <li>Make sure <em>chis_tnr</em> and <em>chis_trg</em> are a lists of integers (or at least singlet lists of one integer) and sorted from small to large.</li>
    <li>If several chis to loop over are given but there is no epsilon to determine sufficient accuracy, then just use the largest chi.</li>
    </ul><blockquote><p class="foldccd93702-64b2-11e7-967e-a820660f017d">Beginning of <strong>symmetrize_A_list</strong>:</p><div class="unfoldccd93702-64b2-11e7-967e-a820660f017d"> Symmetrizes <em>A_list</em> according to the value of <em>horz_refl</em>. <br/><p class="param_use"><em>horz_relf</em> is true, transpose A[0] to get A[1]</p></div>End of <strong>symmetrize_A_list</strong></blockquote><blockquote><p class="foldccd9d9fe-64b2-11e7-9a3e-a820660f017d">Beginning of <strong>split_A_list</strong>:</p><div class="unfoldccd9d9fe-64b2-11e7-9a3e-a820660f017d"> SVDs the tensors in A_list and returns a list of lists with the parts in them. See split_A for details.<br/><blockquote><p class="foldccd9e39a-64b2-11e7-870a-a820660f017d">Beginning of <strong>split_A</strong>:</p><div class="unfoldccd9e39a-64b2-11e7-870a-a820660f017d"><log>Shape of A is[[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/> <br/>Splits an A tensor by SVD into two. eps is the tolerance in the
    SVD, <em>chis</em> is the list of bond dimensions to try when splitting (by
    default the full possible range is tried) and direction specifies
    the way to split.  If direction == 'nesw' (case and space
    insensitive) the splitting is done so that the northeast and
    southwest components are created, and similarly for direction ==
    'nwse'. For all other values of direction both splittings are done.
    The values are returned in the order A_NW, A_SE, A_NE, A_SW,
    possibly leaving out some based on direction.<br/>
    <br/><log>Split A NWSE with chi=36</log><br/><log>split A in NWSE direction,bond dimensions are like:<br/>A_NW:[[5, 5], [5, 5], [18, 18]]<br/>A_SE:[[18, 18], [5, 5], [5, 5]]<br/></log>The final result of split_A is a list, of which the elements are like A_NW,..., and each element has three external legs.<br/></div>End of <strong>split_A</strong></blockquote><blockquote><p class="foldccdb2b70-64b2-11e7-9d3f-a820660f017d">Beginning of <strong>split_A</strong>:</p><div class="unfoldccdb2b70-64b2-11e7-9d3f-a820660f017d"><log>Shape of A is[[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/> <br/>Splits an A tensor by SVD into two. eps is the tolerance in the
    SVD, <em>chis</em> is the list of bond dimensions to try when splitting (by
    default the full possible range is tried) and direction specifies
    the way to split.  If direction == 'nesw' (case and space
    insensitive) the splitting is done so that the northeast and
    southwest components are created, and similarly for direction ==
    'nwse'. For all other values of direction both splittings are done.
    The values are returned in the order A_NW, A_SE, A_NE, A_SW,
    possibly leaving out some based on direction.<br/>
    <log>Split A NESW with chi=36<br/>split A in NESW direction,bond dimensions are like:<br/>A_NE:[[5, 5], [5, 5], [18, 18]]<br/>A_SW:[[5, 5], [18, 18], [5, 5]]</log><br/>The final result of split_A is a list, of which the elements are like A_NW,..., and each element has three external legs.<br/></div>End of <strong>split_A</strong></blockquote>A_part_list = [split(A[0],nwse),split(A[1],nesw)]<br/>A_part_list[0]=split(A0,nwse)<br/>A_part_list[1]=split(A1,nesw)<br/>A_part_list[0][0]=A_NW<br/>A_part_list[0][1]=A_SE<br/>A_part_list[1][0]=A_NE<br/>A_part_list[1][1]=A_SW</div>End of <strong>split_A_list</strong></blockquote> store the result of <strong>split_A_list</strong> to <em>A_part_list</em><br/>
    A_part_list in only used in upb when pars[use_part] is true, otherwise this A_part_list is never used.<br>
     use SVDed A if chi_split < chi_orig**(3/2)<br/>calculate <em>chi_orig</em> and <em>chi_split</em> from <em>A_NW</em>,then determine whether to use the SVD of the original tensor, based on a rough estimate of whether it's computationally advantageous.<iptt>pars["use_parts"] = chi_split < chi_orig**(3/2)</iptt>Not using the SVDed A.<br/><br/>Obtain the optimized <em>u,v,w</em>.<br/><blockquote><p class="foldccdc6ab4-64b2-11e7-acf4-a820660f017d">Beginning of <strong>build_uvw</strong>:</p><div class="unfoldccdc6ab4-64b2-11e7-acf4-a820660f017d">This function optimize the u,v_R,v_L independently(linearly) as in the paper.<br/>Loop over growing truncation dimensions until the truncation error is small enough.<br/><br/> recall that chi_prime < chi^2, so the truncation dimension grows from chi to chi_prime after one TNR step<br/><blockquote><p class="foldccde15be-64b2-11e7-bb7a-a820660f017d">Beginning of <strong>for loop</strong>:</p><div class="unfoldccde15be-64b2-11e7-bb7a-a820660f017d"><pre>for <em>chi_num, chi</em> in enumerate(pars["chis_tnr"]):</pre><br/>loop over <em>chis_tnr</em> the bond dimension<br/><enumerate object at 0x10d8341f8><br/>Optimizing for chi = 6.<br/><blockquote><p class="foldccde1d1c-64b2-11e7-b52a-a820660f017d">Beginning of <strong>initial_uvw</strong>:</p><div class="unfoldccde1d1c-64b2-11e7-b52a-a820660f017d"> Returns the initial disentangler and isometries that are the starting point of the optimization. The initial u is the identity, the initial isometries are SVDed from A just like in TRG, truncated to dimension chi.<br/><br/><log>initial u has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/><log>initial v has shape: [[5, 5], [3, 3], [5, 5]]</log><br/><log>initial w has shape: [[3, 3], [5, 5], [5, 5]]</log><br/></div>End of <strong>initial_uvw</strong></blockquote>there is <iptt>a while loop in this for loop</iptt> to optimize u,v,w<br/><pre>while (cost_change > pars["opt_eps_conv"] and counter < pars["opt_max_iter"]):
                counter += 1
                old_cost = new_cost
                v, w = <strong>optimize_isometries</strong>(u, v, w, A_list, A_part_list, pars, gauges)
                u, B_norm = <strong>optimize_disentangler</strong>(u, v, w, A_list, A_part_list, pars, return_B_norm=True)</pre><br/> keep optimizing u,v,w iteratively to <iptt>maximize the norm of B</iptt> until the relative change is less than <em>opt_eps_conv</em>. if convergence is not reached in <em>opt_max_iter</em> steps, stop and move on</div>End of <strong>for loop</strong></blockquote><log>Truncated bond dimension in TNR: 6</log><br/><log>Optimization converged after 10 iterations.</log><br/><log>Relative error in optimized, truncated TNR block is: 1.376e-03 + 0j</log><br/><log>u has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/><log>v has shape: [[5, 5], [3, 3], [5, 5]]</log><br/><log>w has shape: [[3, 3], [5, 5], [5, 5]]</log><br/></div>End of <strong>build_uvw</strong></blockquote>Build the intermediate tensors <em>B</em> and <em>z</em> and use them to derive <em>A_new</em>.<br/><blockquote><p class="foldcd3a3ffe-64b2-11e7-be7a-a820660f017d">Beginning of <strong>build_B</strong>:</p><div class="unfoldcd3a3ffe-64b2-11e7-be7a-a820660f017d"></div>End of <strong>build_B</strong></blockquote>This step is very simple, since <em>upb</em> (the upper half of B) is totally determined by <em>u,v,w</em> and <em>A</em>, just contract <em>upb</em> with upb^dagger<br/><br/><log>before splitting B has shape: [[3, 3], [3, 3], [3, 3], [3, 3]]</log><br/><blockquote><p class="foldcd3bf268-64b2-11e7-9e0f-a820660f017d">Beginning of <strong>split_B</strong>:</p><div class="unfoldcd3bf268-64b2-11e7-9e0f-a820660f017d">no optimization in split_B, just take out the SVDed value<br/><log>The splitting result has shape:<br/>US (should be U*sqrt(S) ): [[3, 3], [5, 5], [3, 3]]<br/>SV (should be sqrt(S)*V ): [[5, 5], [3, 3], [3, 3]]<br/></log><log>Truncated bond dimension in split_B: 10</log><br/></div>End of <strong>split_B</strong></blockquote>split B horizontally, BUS,BSV = B.svd((0,3), (1,2))<br/>obtain <em>BUS, BSV</em> from <strong>split_B</strong>.<br/> <div class="codeblock">splitting B with chis=chis_trg</div><p class="param_use"><em>return_gauges</em> is true, then derive <em>G_hh</em> from <strong>split_B</strong></p><blockquote><p class="foldcd3c641e-64b2-11e7-9cd2-a820660f017d">Beginning of <strong>build_z</strong>:</p><div class="unfoldcd3c641e-64b2-11e7-9cd2-a820660f017d">also no optimization in build_z, calculate the environment <em>M</em> and SVD it.<br/><log>the environment of z has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/><log>z has shape: [[5, 5], [5, 5], [5, 5]]</log><br/><log>Truncated bond dimension in build_z: 10</log><br/></div>End of <strong>build_z</strong></blockquote>mapping from the parameters used here to that used in the paper'algorithms in TNR'
    <pre>
    u ---> u
    w ---> v_L
    v ---> v_R
    z ---> w
    </pre>
    <blockquote><p class="foldcd3f292e-64b2-11e7-85e9-a820660f017d">Beginning of <strong>build_A_new</strong>:</p><div class="unfoldcd3f292e-64b2-11e7-85e9-a820660f017d"><log><em>A_new</em> has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/></div>End of <strong>build_A_new</strong></blockquote>Scale A_new to have largest values around unity and use that to update new_log_fact.<br/>normalize <em>A_new</em> to have unit norm<br><iptt>new_log_fact = np.log(fact) + 4*log_fact</iptt>, here <em>fact</em> is the original norm of <em>A_new</em>, <em>log_fact is inherited from pars[...]</em><br/>obtain renewed <strong>A_new,BUS,BSV,z</strong> from <strong>fix_A_new_gauge</strong><p class="param_use"><br/>also obtain G_hh if "return_gauges" is true</p><blockquote><p class="foldcd412ff8-64b2-11e7-afb6-a820660f017d">Beginning of <strong>fix_A_new_gauge</strong>:</p><div class="unfoldcd412ff8-64b2-11e7-afb6-a820660f017d"><blockquote><p class="foldcd41aa80-64b2-11e7-8354-a820660f017d">Beginning of <strong>while loop under cost_change > 1e-11 and counter < 10000</strong>:</p><div class="unfoldcd41aa80-64b2-11e7-8354-a820660f017d"><blockquote><p class="foldcd41ae62-64b2-11e7-b340-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldcd41ae62-64b2-11e7-b340-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldcd42c2e6-64b2-11e7-b0a9-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldcd42c2e6-64b2-11e7-b0a9-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote><blockquote><p class="foldcd43deba-64b2-11e7-a614-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldcd43deba-64b2-11e7-a614-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldcd44b754-64b2-11e7-b391-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldcd44b754-64b2-11e7-b391-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote><blockquote><p class="foldcd45dd1e-64b2-11e7-93b1-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldcd45dd1e-64b2-11e7-93b1-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldcd46d192-64b2-11e7-8df0-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldcd46d192-64b2-11e7-8df0-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote><blockquote><p class="foldcd480d00-64b2-11e7-ac11-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldcd480d00-64b2-11e7-ac11-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldcd491074-64b2-11e7-9f14-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldcd491074-64b2-11e7-9f14-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote><blockquote><p class="foldcd4a0e8c-64b2-11e7-8e9f-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldcd4a0e8c-64b2-11e7-8e9f-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldcd4b0f34-64b2-11e7-8ed6-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldcd4b0f34-64b2-11e7-8ed6-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote></div>End of <strong>while loop</strong></blockquote><blockquote><p class="foldcd4c07ae-64b2-11e7-aca0-a820660f017d">Beginning of <strong>fix_A_new_gauge_update_to_gauge</strong>:</p><div class="unfoldcd4c07ae-64b2-11e7-aca0-a820660f017d"></div>End of <strong>fix_A_new_gauge_update_to_gauge</strong></blockquote></div>End of <strong>fix_A_new_gauge</strong></blockquote>Put A_new,new_log_fact to return value<br><p class="param_use">return_pieces is true, put A_part_list,u,v,w,B,BUS,BSV,z into return value</p><p class="param_use">return_gauges & horz_refl true, then optimize_G_hv</p><blockquote><p class="foldcd4d9f68-64b2-11e7-9d61-a820660f017d">Beginning of <strong>optimize_G_hv</strong>:</p><div class="unfoldcd4d9f68-64b2-11e7-9d61-a820660f017d"><blockquote><p class="foldcd4e1074-64b2-11e7-8efe-a820660f017d">Beginning of <strong>while loop under cost_change > 1e-11 and counter < 10000</strong>:</p><div class="unfoldcd4e1074-64b2-11e7-8efe-a820660f017d"></div>End of <strong>while loop</strong></blockquote><log>After 3 iterations, error in optimize_G_hv is 5.851e-15.</log><br/><log><em>G_hv</em> has shape: [[5, 5], [5, 5]]</log><br/></div>End of <strong>optimize_G_hv</strong></blockquote><blockquote><p class="foldcd50b694-64b2-11e7-b1e8-a820660f017d">Beginning of <strong>optimize_G_vh</strong>:</p><div class="unfoldcd50b694-64b2-11e7-b1e8-a820660f017d"><blockquote><p class="foldcd50ca26-64b2-11e7-8043-a820660f017d">Beginning of <strong>while loop under cost_change > 1e-11 and counter < 10000</strong>:</p><div class="unfoldcd50ca26-64b2-11e7-8043-a820660f017d"></div>End of <strong>while loop</strong></blockquote><log>After 3 iterations, error in optimize_G_vh is 2.765e-15.</log><br/><log><em>G_vh</em> has shape: [[5, 5], [5, 5]]</log><br/></div>End of <strong>optimize_G_vh</strong></blockquote>put G_hh,G_hv,G_vh into return value</div>End of <strong>TNR_step</strong></blockquote></div>End of <strong>generate_next_tensor</strong></blockquote></div>End of <strong>generate_tensor</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_tensor</strong></blockquote><blockquote><p class="foldcd544a9a-64b2-11e7-ae38-a820660f017d">Beginning of <strong>get_tensor</strong>:</p><div class="unfoldcd544a9a-64b2-11e7-ae38-a820660f017d"><blockquote><p class="foldcd5450d0-64b2-11e7-90bf-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfoldcd5450d0-64b2-11e7-90bf-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="foldcd545682-64b2-11e7-9e15-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfoldcd545682-64b2-11e7-9e15-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote><blockquote><p class="foldcd5462f8-64b2-11e7-a97c-a820660f017d">Beginning of <strong>generate_tensor</strong>:</p><div class="unfoldcd5462f8-64b2-11e7-a97c-a820660f017d"><blockquote><p class="foldcd546726-64b2-11e7-a75b-a820660f017d">Beginning of <strong>generate_next_tensor</strong>:</p><div class="unfoldcd546726-64b2-11e7-a75b-a820660f017d"><blockquote><p class="foldcd546bcc-64b2-11e7-bb21-a820660f017d">Beginning of <strong>get_tensor</strong>:</p><div class="unfoldcd546bcc-64b2-11e7-bb21-a820660f017d"><blockquote><p class="foldcd5472c0-64b2-11e7-9e53-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfoldcd5472c0-64b2-11e7-9e53-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="foldcd54782e-64b2-11e7-898f-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfoldcd54782e-64b2-11e7-898f-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_tensor</strong></blockquote> Coarse-graining, iter_count = #8: / <br/><blockquote><p class="foldcd549c3e-64b2-11e7-9b71-a820660f017d">Beginning of <strong>get_gauges</strong>:</p><div class="unfoldcd549c3e-64b2-11e7-9b71-a820660f017d"><blockquote><p class="foldcd54a38a-64b2-11e7-b37e-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfoldcd54a38a-64b2-11e7-b37e-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="foldcd54a7ec-64b2-11e7-9c87-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfoldcd54a7ec-64b2-11e7-9c87-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_gauges</strong></blockquote><blockquote><p class="foldcd54bf78-64b2-11e7-8a5c-a820660f017d">Beginning of <strong>get_pieces</strong>:</p><div class="unfoldcd54bf78-64b2-11e7-8a5c-a820660f017d"><blockquote><p class="foldcd54c338-64b2-11e7-b609-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfoldcd54c338-64b2-11e7-b609-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="foldcd54c6e4-64b2-11e7-bc2f-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfoldcd54c6e4-64b2-11e7-bc2f-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_pieces</strong></blockquote><blockquote><p class="foldcd550730-64b2-11e7-91cc-a820660f017d">Beginning of <strong>TNR_step</strong>:</p><div class="unfoldcd550730-64b2-11e7-91cc-a820660f017d">The function <strong>format_parameters</strong> formats some of the parameters given to <em>tnr_step</em> to a canonical form.<br/><ul>
    <li>Make sure <em>A_list</em> is a list of 2 tensors</li>
    <li>Create pars, gauges and pieces.</li>
    <li>Values are taken primarily from kwargs, then from pars, gauges and pieces, and finally from default. Only ones listed in defaults are used, others are ignored.</li>
    <li>Make sure <em>chis_tnr</em> and <em>chis_trg</em> are a lists of integers (or at least singlet lists of one integer) and sorted from small to large.</li>
    <li>If several chis to loop over are given but there is no epsilon to determine sufficient accuracy, then just use the largest chi.</li>
    </ul><blockquote><p class="foldcd55105c-64b2-11e7-8a36-a820660f017d">Beginning of <strong>symmetrize_A_list</strong>:</p><div class="unfoldcd55105c-64b2-11e7-8a36-a820660f017d"> Symmetrizes <em>A_list</em> according to the value of <em>horz_refl</em>. <br/><p class="param_use"><em>horz_relf</em> is true, transpose A[0] to get A[1]</p></div>End of <strong>symmetrize_A_list</strong></blockquote><blockquote><p class="foldcd559c9a-64b2-11e7-8ae8-a820660f017d">Beginning of <strong>split_A_list</strong>:</p><div class="unfoldcd559c9a-64b2-11e7-8ae8-a820660f017d"> SVDs the tensors in A_list and returns a list of lists with the parts in them. See split_A for details.<br/><blockquote><p class="foldcd55a74c-64b2-11e7-a10a-a820660f017d">Beginning of <strong>split_A</strong>:</p><div class="unfoldcd55a74c-64b2-11e7-a10a-a820660f017d"><log>Shape of A is[[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/> <br/>Splits an A tensor by SVD into two. eps is the tolerance in the
    SVD, <em>chis</em> is the list of bond dimensions to try when splitting (by
    default the full possible range is tried) and direction specifies
    the way to split.  If direction == 'nesw' (case and space
    insensitive) the splitting is done so that the northeast and
    southwest components are created, and similarly for direction ==
    'nwse'. For all other values of direction both splittings are done.
    The values are returned in the order A_NW, A_SE, A_NE, A_SW,
    possibly leaving out some based on direction.<br/>
    <br/><log>Split A NWSE with chi=36</log><br/><log>split A in NWSE direction,bond dimensions are like:<br/>A_NW:[[5, 5], [5, 5], [18, 18]]<br/>A_SE:[[18, 18], [5, 5], [5, 5]]<br/></log>The final result of split_A is a list, of which the elements are like A_NW,..., and each element has three external legs.<br/></div>End of <strong>split_A</strong></blockquote><blockquote><p class="foldcd56e000-64b2-11e7-9d38-a820660f017d">Beginning of <strong>split_A</strong>:</p><div class="unfoldcd56e000-64b2-11e7-9d38-a820660f017d"><log>Shape of A is[[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/> <br/>Splits an A tensor by SVD into two. eps is the tolerance in the
    SVD, <em>chis</em> is the list of bond dimensions to try when splitting (by
    default the full possible range is tried) and direction specifies
    the way to split.  If direction == 'nesw' (case and space
    insensitive) the splitting is done so that the northeast and
    southwest components are created, and similarly for direction ==
    'nwse'. For all other values of direction both splittings are done.
    The values are returned in the order A_NW, A_SE, A_NE, A_SW,
    possibly leaving out some based on direction.<br/>
    <log>Split A NESW with chi=36<br/>split A in NESW direction,bond dimensions are like:<br/>A_NE:[[5, 5], [5, 5], [18, 18]]<br/>A_SW:[[5, 5], [18, 18], [5, 5]]</log><br/>The final result of split_A is a list, of which the elements are like A_NW,..., and each element has three external legs.<br/></div>End of <strong>split_A</strong></blockquote>A_part_list = [split(A[0],nwse),split(A[1],nesw)]<br/>A_part_list[0]=split(A0,nwse)<br/>A_part_list[1]=split(A1,nesw)<br/>A_part_list[0][0]=A_NW<br/>A_part_list[0][1]=A_SE<br/>A_part_list[1][0]=A_NE<br/>A_part_list[1][1]=A_SW</div>End of <strong>split_A_list</strong></blockquote> store the result of <strong>split_A_list</strong> to <em>A_part_list</em><br/>
    A_part_list in only used in upb when pars[use_part] is true, otherwise this A_part_list is never used.<br>
     use SVDed A if chi_split < chi_orig**(3/2)<br/>calculate <em>chi_orig</em> and <em>chi_split</em> from <em>A_NW</em>,then determine whether to use the SVD of the original tensor, based on a rough estimate of whether it's computationally advantageous.<iptt>pars["use_parts"] = chi_split < chi_orig**(3/2)</iptt>Not using the SVDed A.<br/><br/>Obtain the optimized <em>u,v,w</em>.<br/><blockquote><p class="foldcd581bf8-64b2-11e7-8336-a820660f017d">Beginning of <strong>build_uvw</strong>:</p><div class="unfoldcd581bf8-64b2-11e7-8336-a820660f017d">This function optimize the u,v_R,v_L independently(linearly) as in the paper.<br/>Loop over growing truncation dimensions until the truncation error is small enough.<br/><br/> recall that chi_prime < chi^2, so the truncation dimension grows from chi to chi_prime after one TNR step<br/><blockquote><p class="foldcd59359c-64b2-11e7-af4d-a820660f017d">Beginning of <strong>for loop</strong>:</p><div class="unfoldcd59359c-64b2-11e7-af4d-a820660f017d"><pre>for <em>chi_num, chi</em> in enumerate(pars["chis_tnr"]):</pre><br/>loop over <em>chis_tnr</em> the bond dimension<br/><enumerate object at 0x10d8343f0><br/>Optimizing for chi = 6.<br/><blockquote><p class="foldcd59439a-64b2-11e7-993d-a820660f017d">Beginning of <strong>initial_uvw</strong>:</p><div class="unfoldcd59439a-64b2-11e7-993d-a820660f017d"> Returns the initial disentangler and isometries that are the starting point of the optimization. The initial u is the identity, the initial isometries are SVDed from A just like in TRG, truncated to dimension chi.<br/><br/><log>initial u has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/><log>initial v has shape: [[5, 5], [3, 3], [5, 5]]</log><br/><log>initial w has shape: [[3, 3], [5, 5], [5, 5]]</log><br/></div>End of <strong>initial_uvw</strong></blockquote>there is <iptt>a while loop in this for loop</iptt> to optimize u,v,w<br/><pre>while (cost_change > pars["opt_eps_conv"] and counter < pars["opt_max_iter"]):
                counter += 1
                old_cost = new_cost
                v, w = <strong>optimize_isometries</strong>(u, v, w, A_list, A_part_list, pars, gauges)
                u, B_norm = <strong>optimize_disentangler</strong>(u, v, w, A_list, A_part_list, pars, return_B_norm=True)</pre><br/> keep optimizing u,v,w iteratively to <iptt>maximize the norm of B</iptt> until the relative change is less than <em>opt_eps_conv</em>. if convergence is not reached in <em>opt_max_iter</em> steps, stop and move on</div>End of <strong>for loop</strong></blockquote><log>Truncated bond dimension in TNR: 6</log><br/><log>Optimization converged after 10 iterations.</log><br/><log>Relative error in optimized, truncated TNR block is: 1.380e-03 + 0j</log><br/><log>u has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/><log>v has shape: [[5, 5], [3, 3], [5, 5]]</log><br/><log>w has shape: [[3, 3], [5, 5], [5, 5]]</log><br/></div>End of <strong>build_uvw</strong></blockquote>Build the intermediate tensors <em>B</em> and <em>z</em> and use them to derive <em>A_new</em>.<br/><blockquote><p class="foldcdb5bbb6-64b2-11e7-9e34-a820660f017d">Beginning of <strong>build_B</strong>:</p><div class="unfoldcdb5bbb6-64b2-11e7-9e34-a820660f017d"></div>End of <strong>build_B</strong></blockquote>This step is very simple, since <em>upb</em> (the upper half of B) is totally determined by <em>u,v,w</em> and <em>A</em>, just contract <em>upb</em> with upb^dagger<br/><br/><log>before splitting B has shape: [[3, 3], [3, 3], [3, 3], [3, 3]]</log><br/><blockquote><p class="foldcdb7641e-64b2-11e7-8d56-a820660f017d">Beginning of <strong>split_B</strong>:</p><div class="unfoldcdb7641e-64b2-11e7-8d56-a820660f017d">no optimization in split_B, just take out the SVDed value<br/><log>The splitting result has shape:<br/>US (should be U*sqrt(S) ): [[3, 3], [5, 5], [3, 3]]<br/>SV (should be sqrt(S)*V ): [[5, 5], [3, 3], [3, 3]]<br/></log><log>Truncated bond dimension in split_B: 10</log><br/></div>End of <strong>split_B</strong></blockquote>split B horizontally, BUS,BSV = B.svd((0,3), (1,2))<br/>obtain <em>BUS, BSV</em> from <strong>split_B</strong>.<br/> <div class="codeblock">splitting B with chis=chis_trg</div><p class="param_use"><em>return_gauges</em> is true, then derive <em>G_hh</em> from <strong>split_B</strong></p><blockquote><p class="foldcdb7e922-64b2-11e7-8da4-a820660f017d">Beginning of <strong>build_z</strong>:</p><div class="unfoldcdb7e922-64b2-11e7-8da4-a820660f017d">also no optimization in build_z, calculate the environment <em>M</em> and SVD it.<br/><log>the environment of z has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/><log>z has shape: [[5, 5], [5, 5], [5, 5]]</log><br/><log>Truncated bond dimension in build_z: 10</log><br/></div>End of <strong>build_z</strong></blockquote>mapping from the parameters used here to that used in the paper'algorithms in TNR'
    <pre>
    u ---> u
    w ---> v_L
    v ---> v_R
    z ---> w
    </pre>
    <blockquote><p class="foldcdba4c2e-64b2-11e7-9715-a820660f017d">Beginning of <strong>build_A_new</strong>:</p><div class="unfoldcdba4c2e-64b2-11e7-9715-a820660f017d"><log><em>A_new</em> has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/></div>End of <strong>build_A_new</strong></blockquote>Scale A_new to have largest values around unity and use that to update new_log_fact.<br/>normalize <em>A_new</em> to have unit norm<br><iptt>new_log_fact = np.log(fact) + 4*log_fact</iptt>, here <em>fact</em> is the original norm of <em>A_new</em>, <em>log_fact is inherited from pars[...]</em><br/>obtain renewed <strong>A_new,BUS,BSV,z</strong> from <strong>fix_A_new_gauge</strong><p class="param_use"><br/>also obtain G_hh if "return_gauges" is true</p><blockquote><p class="foldcdbb9090-64b2-11e7-b734-a820660f017d">Beginning of <strong>fix_A_new_gauge</strong>:</p><div class="unfoldcdbb9090-64b2-11e7-b734-a820660f017d"><blockquote><p class="foldcdbbe5ae-64b2-11e7-b945-a820660f017d">Beginning of <strong>while loop under cost_change > 1e-11 and counter < 10000</strong>:</p><div class="unfoldcdbbe5ae-64b2-11e7-b945-a820660f017d"><blockquote><p class="foldcdbbe964-64b2-11e7-acb3-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldcdbbe964-64b2-11e7-acb3-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldcdbd1e4a-64b2-11e7-a45a-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldcdbd1e4a-64b2-11e7-a45a-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote><blockquote><p class="foldcdbe2328-64b2-11e7-a24a-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldcdbe2328-64b2-11e7-a24a-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldcdbf3830-64b2-11e7-acb1-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldcdbf3830-64b2-11e7-acb1-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote><blockquote><p class="foldcdc02e66-64b2-11e7-a4f9-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldcdc02e66-64b2-11e7-a4f9-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldcdc1375c-64b2-11e7-bf2b-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldcdc1375c-64b2-11e7-bf2b-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote><blockquote><p class="foldcdc28db4-64b2-11e7-b9cc-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldcdc28db4-64b2-11e7-b9cc-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldcdc38502-64b2-11e7-91ae-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldcdc38502-64b2-11e7-91ae-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote><blockquote><p class="foldcdc4a964-64b2-11e7-ad4d-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldcdc4a964-64b2-11e7-ad4d-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldcdc588ae-64b2-11e7-b3e0-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldcdc588ae-64b2-11e7-b3e0-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote></div>End of <strong>while loop</strong></blockquote><blockquote><p class="foldcdc694c2-64b2-11e7-9b06-a820660f017d">Beginning of <strong>fix_A_new_gauge_update_to_gauge</strong>:</p><div class="unfoldcdc694c2-64b2-11e7-9b06-a820660f017d"></div>End of <strong>fix_A_new_gauge_update_to_gauge</strong></blockquote></div>End of <strong>fix_A_new_gauge</strong></blockquote>Put A_new,new_log_fact to return value<br><p class="param_use">return_pieces is true, put A_part_list,u,v,w,B,BUS,BSV,z into return value</p><p class="param_use">return_gauges & horz_refl true, then optimize_G_hv</p><blockquote><p class="foldcdc7f452-64b2-11e7-b61c-a820660f017d">Beginning of <strong>optimize_G_hv</strong>:</p><div class="unfoldcdc7f452-64b2-11e7-b61c-a820660f017d"><blockquote><p class="foldcdc867c0-64b2-11e7-bf3b-a820660f017d">Beginning of <strong>while loop under cost_change > 1e-11 and counter < 10000</strong>:</p><div class="unfoldcdc867c0-64b2-11e7-bf3b-a820660f017d"></div>End of <strong>while loop</strong></blockquote><log>After 3 iterations, error in optimize_G_hv is 3.609e-15.</log><br/><log><em>G_hv</em> has shape: [[5, 5], [5, 5]]</log><br/></div>End of <strong>optimize_G_hv</strong></blockquote><blockquote><p class="foldcdcb1268-64b2-11e7-bf93-a820660f017d">Beginning of <strong>optimize_G_vh</strong>:</p><div class="unfoldcdcb1268-64b2-11e7-bf93-a820660f017d"><blockquote><p class="foldcdcb251e-64b2-11e7-bd56-a820660f017d">Beginning of <strong>while loop under cost_change > 1e-11 and counter < 10000</strong>:</p><div class="unfoldcdcb251e-64b2-11e7-bd56-a820660f017d"></div>End of <strong>while loop</strong></blockquote><log>After 3 iterations, error in optimize_G_vh is 2.607e-15.</log><br/><log><em>G_vh</em> has shape: [[5, 5], [5, 5]]</log><br/></div>End of <strong>optimize_G_vh</strong></blockquote>put G_hh,G_hv,G_vh into return value</div>End of <strong>TNR_step</strong></blockquote></div>End of <strong>generate_next_tensor</strong></blockquote></div>End of <strong>generate_tensor</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_tensor</strong></blockquote><blockquote><p class="foldcdceef46-64b2-11e7-b0f1-a820660f017d">Beginning of <strong>get_tensor</strong>:</p><div class="unfoldcdceef46-64b2-11e7-b0f1-a820660f017d"><blockquote><p class="foldcdcef46e-64b2-11e7-8665-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfoldcdcef46e-64b2-11e7-8665-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="foldcdcef8d8-64b2-11e7-8152-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfoldcdcef8d8-64b2-11e7-8152-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote><blockquote><p class="foldcdcf029c-64b2-11e7-8418-a820660f017d">Beginning of <strong>generate_tensor</strong>:</p><div class="unfoldcdcf029c-64b2-11e7-8418-a820660f017d"><blockquote><p class="foldcdcf0602-64b2-11e7-a015-a820660f017d">Beginning of <strong>generate_next_tensor</strong>:</p><div class="unfoldcdcf0602-64b2-11e7-a015-a820660f017d"><blockquote><p class="foldcdcf099a-64b2-11e7-a8b2-a820660f017d">Beginning of <strong>get_tensor</strong>:</p><div class="unfoldcdcf099a-64b2-11e7-a8b2-a820660f017d"><blockquote><p class="foldcdcf0d0a-64b2-11e7-ae32-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfoldcdcf0d0a-64b2-11e7-ae32-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="foldcdcf1086-64b2-11e7-a222-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfoldcdcf1086-64b2-11e7-a222-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_tensor</strong></blockquote> Coarse-graining, iter_count = #9: / <br/><blockquote><p class="foldcdcf2a10-64b2-11e7-91aa-a820660f017d">Beginning of <strong>get_gauges</strong>:</p><div class="unfoldcdcf2a10-64b2-11e7-91aa-a820660f017d"><blockquote><p class="foldcdcf2fa6-64b2-11e7-b362-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfoldcdcf2fa6-64b2-11e7-b362-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="foldcdcf347e-64b2-11e7-b63f-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfoldcdcf347e-64b2-11e7-b63f-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_gauges</strong></blockquote><blockquote><p class="foldcdcf4854-64b2-11e7-a58d-a820660f017d">Beginning of <strong>get_pieces</strong>:</p><div class="unfoldcdcf4854-64b2-11e7-a58d-a820660f017d"><blockquote><p class="foldcdcf4c0c-64b2-11e7-ac9f-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfoldcdcf4c0c-64b2-11e7-ac9f-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="foldcdcf4fcc-64b2-11e7-91f3-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfoldcdcf4fcc-64b2-11e7-91f3-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_pieces</strong></blockquote><blockquote><p class="foldcdcf79a4-64b2-11e7-bb21-a820660f017d">Beginning of <strong>TNR_step</strong>:</p><div class="unfoldcdcf79a4-64b2-11e7-bb21-a820660f017d">The function <strong>format_parameters</strong> formats some of the parameters given to <em>tnr_step</em> to a canonical form.<br/><ul>
    <li>Make sure <em>A_list</em> is a list of 2 tensors</li>
    <li>Create pars, gauges and pieces.</li>
    <li>Values are taken primarily from kwargs, then from pars, gauges and pieces, and finally from default. Only ones listed in defaults are used, others are ignored.</li>
    <li>Make sure <em>chis_tnr</em> and <em>chis_trg</em> are a lists of integers (or at least singlet lists of one integer) and sorted from small to large.</li>
    <li>If several chis to loop over are given but there is no epsilon to determine sufficient accuracy, then just use the largest chi.</li>
    </ul><blockquote><p class="foldcdcf8082-64b2-11e7-8112-a820660f017d">Beginning of <strong>symmetrize_A_list</strong>:</p><div class="unfoldcdcf8082-64b2-11e7-8112-a820660f017d"> Symmetrizes <em>A_list</em> according to the value of <em>horz_refl</em>. <br/><p class="param_use"><em>horz_relf</em> is true, transpose A[0] to get A[1]</p></div>End of <strong>symmetrize_A_list</strong></blockquote><blockquote><p class="foldcdd01a24-64b2-11e7-a27c-a820660f017d">Beginning of <strong>split_A_list</strong>:</p><div class="unfoldcdd01a24-64b2-11e7-a27c-a820660f017d"> SVDs the tensors in A_list and returns a list of lists with the parts in them. See split_A for details.<br/><blockquote><p class="foldcdd0249c-64b2-11e7-8561-a820660f017d">Beginning of <strong>split_A</strong>:</p><div class="unfoldcdd0249c-64b2-11e7-8561-a820660f017d"><log>Shape of A is[[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/> <br/>Splits an A tensor by SVD into two. eps is the tolerance in the
    SVD, <em>chis</em> is the list of bond dimensions to try when splitting (by
    default the full possible range is tried) and direction specifies
    the way to split.  If direction == 'nesw' (case and space
    insensitive) the splitting is done so that the northeast and
    southwest components are created, and similarly for direction ==
    'nwse'. For all other values of direction both splittings are done.
    The values are returned in the order A_NW, A_SE, A_NE, A_SW,
    possibly leaving out some based on direction.<br/>
    <br/><log>Split A NWSE with chi=36</log><br/><log>split A in NWSE direction,bond dimensions are like:<br/>A_NW:[[5, 5], [5, 5], [18, 18]]<br/>A_SE:[[18, 18], [5, 5], [5, 5]]<br/></log>The final result of split_A is a list, of which the elements are like A_NW,..., and each element has three external legs.<br/></div>End of <strong>split_A</strong></blockquote><blockquote><p class="foldcdd15cec-64b2-11e7-b64d-a820660f017d">Beginning of <strong>split_A</strong>:</p><div class="unfoldcdd15cec-64b2-11e7-b64d-a820660f017d"><log>Shape of A is[[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/> <br/>Splits an A tensor by SVD into two. eps is the tolerance in the
    SVD, <em>chis</em> is the list of bond dimensions to try when splitting (by
    default the full possible range is tried) and direction specifies
    the way to split.  If direction == 'nesw' (case and space
    insensitive) the splitting is done so that the northeast and
    southwest components are created, and similarly for direction ==
    'nwse'. For all other values of direction both splittings are done.
    The values are returned in the order A_NW, A_SE, A_NE, A_SW,
    possibly leaving out some based on direction.<br/>
    <log>Split A NESW with chi=36<br/>split A in NESW direction,bond dimensions are like:<br/>A_NE:[[5, 5], [5, 5], [18, 18]]<br/>A_SW:[[5, 5], [18, 18], [5, 5]]</log><br/>The final result of split_A is a list, of which the elements are like A_NW,..., and each element has three external legs.<br/></div>End of <strong>split_A</strong></blockquote>A_part_list = [split(A[0],nwse),split(A[1],nesw)]<br/>A_part_list[0]=split(A0,nwse)<br/>A_part_list[1]=split(A1,nesw)<br/>A_part_list[0][0]=A_NW<br/>A_part_list[0][1]=A_SE<br/>A_part_list[1][0]=A_NE<br/>A_part_list[1][1]=A_SW</div>End of <strong>split_A_list</strong></blockquote> store the result of <strong>split_A_list</strong> to <em>A_part_list</em><br/>
    A_part_list in only used in upb when pars[use_part] is true, otherwise this A_part_list is never used.<br>
     use SVDed A if chi_split < chi_orig**(3/2)<br/>calculate <em>chi_orig</em> and <em>chi_split</em> from <em>A_NW</em>,then determine whether to use the SVD of the original tensor, based on a rough estimate of whether it's computationally advantageous.<iptt>pars["use_parts"] = chi_split < chi_orig**(3/2)</iptt>Not using the SVDed A.<br/><br/>Obtain the optimized <em>u,v,w</em>.<br/><blockquote><p class="foldcdd280de-64b2-11e7-87b9-a820660f017d">Beginning of <strong>build_uvw</strong>:</p><div class="unfoldcdd280de-64b2-11e7-87b9-a820660f017d">This function optimize the u,v_R,v_L independently(linearly) as in the paper.<br/>Loop over growing truncation dimensions until the truncation error is small enough.<br/><br/> recall that chi_prime < chi^2, so the truncation dimension grows from chi to chi_prime after one TNR step<br/><blockquote><p class="foldcdd3b6a4-64b2-11e7-b00c-a820660f017d">Beginning of <strong>for loop</strong>:</p><div class="unfoldcdd3b6a4-64b2-11e7-b00c-a820660f017d"><pre>for <em>chi_num, chi</em> in enumerate(pars["chis_tnr"]):</pre><br/>loop over <em>chis_tnr</em> the bond dimension<br/><enumerate object at 0x10d882048><br/>Optimizing for chi = 6.<br/><blockquote><p class="foldcdd3bed4-64b2-11e7-b1d7-a820660f017d">Beginning of <strong>initial_uvw</strong>:</p><div class="unfoldcdd3bed4-64b2-11e7-b1d7-a820660f017d"> Returns the initial disentangler and isometries that are the starting point of the optimization. The initial u is the identity, the initial isometries are SVDed from A just like in TRG, truncated to dimension chi.<br/><br/><log>initial u has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/><log>initial v has shape: [[5, 5], [3, 3], [5, 5]]</log><br/><log>initial w has shape: [[3, 3], [5, 5], [5, 5]]</log><br/></div>End of <strong>initial_uvw</strong></blockquote>there is <iptt>a while loop in this for loop</iptt> to optimize u,v,w<br/><pre>while (cost_change > pars["opt_eps_conv"] and counter < pars["opt_max_iter"]):
                counter += 1
                old_cost = new_cost
                v, w = <strong>optimize_isometries</strong>(u, v, w, A_list, A_part_list, pars, gauges)
                u, B_norm = <strong>optimize_disentangler</strong>(u, v, w, A_list, A_part_list, pars, return_B_norm=True)</pre><br/> keep optimizing u,v,w iteratively to <iptt>maximize the norm of B</iptt> until the relative change is less than <em>opt_eps_conv</em>. if convergence is not reached in <em>opt_max_iter</em> steps, stop and move on</div>End of <strong>for loop</strong></blockquote><log>Truncated bond dimension in TNR: 6</log><br/><log>Optimization converged after 13 iterations.</log><br/><log>Relative error in optimized, truncated TNR block is: 1.384e-03 + 0j</log><br/><log>u has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/><log>v has shape: [[5, 5], [3, 3], [5, 5]]</log><br/><log>w has shape: [[3, 3], [5, 5], [5, 5]]</log><br/></div>End of <strong>build_uvw</strong></blockquote>Build the intermediate tensors <em>B</em> and <em>z</em> and use them to derive <em>A_new</em>.<br/><blockquote><p class="foldce46d292-64b2-11e7-996b-a820660f017d">Beginning of <strong>build_B</strong>:</p><div class="unfoldce46d292-64b2-11e7-996b-a820660f017d"></div>End of <strong>build_B</strong></blockquote>This step is very simple, since <em>upb</em> (the upper half of B) is totally determined by <em>u,v,w</em> and <em>A</em>, just contract <em>upb</em> with upb^dagger<br/><br/><log>before splitting B has shape: [[3, 3], [3, 3], [3, 3], [3, 3]]</log><br/><blockquote><p class="foldce489634-64b2-11e7-adca-a820660f017d">Beginning of <strong>split_B</strong>:</p><div class="unfoldce489634-64b2-11e7-adca-a820660f017d">no optimization in split_B, just take out the SVDed value<br/><log>The splitting result has shape:<br/>US (should be U*sqrt(S) ): [[3, 3], [5, 5], [3, 3]]<br/>SV (should be sqrt(S)*V ): [[5, 5], [3, 3], [3, 3]]<br/></log><log>Truncated bond dimension in split_B: 10</log><br/></div>End of <strong>split_B</strong></blockquote>split B horizontally, BUS,BSV = B.svd((0,3), (1,2))<br/>obtain <em>BUS, BSV</em> from <strong>split_B</strong>.<br/> <div class="codeblock">splitting B with chis=chis_trg</div><p class="param_use"><em>return_gauges</em> is true, then derive <em>G_hh</em> from <strong>split_B</strong></p><blockquote><p class="foldce490770-64b2-11e7-8b86-a820660f017d">Beginning of <strong>build_z</strong>:</p><div class="unfoldce490770-64b2-11e7-8b86-a820660f017d">also no optimization in build_z, calculate the environment <em>M</em> and SVD it.<br/><log>the environment of z has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/><log>z has shape: [[5, 5], [5, 5], [5, 5]]</log><br/><log>Truncated bond dimension in build_z: 10</log><br/></div>End of <strong>build_z</strong></blockquote>mapping from the parameters used here to that used in the paper'algorithms in TNR'
    <pre>
    u ---> u
    w ---> v_L
    v ---> v_R
    z ---> w
    </pre>
    <blockquote><p class="foldce4b8c68-64b2-11e7-89c4-a820660f017d">Beginning of <strong>build_A_new</strong>:</p><div class="unfoldce4b8c68-64b2-11e7-89c4-a820660f017d"><log><em>A_new</em> has shape: [[5, 5], [5, 5], [5, 5], [5, 5]]</log><br/></div>End of <strong>build_A_new</strong></blockquote>Scale A_new to have largest values around unity and use that to update new_log_fact.<br/>normalize <em>A_new</em> to have unit norm<br><iptt>new_log_fact = np.log(fact) + 4*log_fact</iptt>, here <em>fact</em> is the original norm of <em>A_new</em>, <em>log_fact is inherited from pars[...]</em><br/>obtain renewed <strong>A_new,BUS,BSV,z</strong> from <strong>fix_A_new_gauge</strong><p class="param_use"><br/>also obtain G_hh if "return_gauges" is true</p><blockquote><p class="foldce4cd3f4-64b2-11e7-9569-a820660f017d">Beginning of <strong>fix_A_new_gauge</strong>:</p><div class="unfoldce4cd3f4-64b2-11e7-9569-a820660f017d"><blockquote><p class="foldce4d5cd2-64b2-11e7-8c80-a820660f017d">Beginning of <strong>while loop under cost_change > 1e-11 and counter < 10000</strong>:</p><div class="unfoldce4d5cd2-64b2-11e7-8c80-a820660f017d"><blockquote><p class="foldce4d61ac-64b2-11e7-b4fa-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldce4d61ac-64b2-11e7-b4fa-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldce4e5e78-64b2-11e7-b35d-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldce4e5e78-64b2-11e7-b35d-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote><blockquote><p class="foldce4f54cc-64b2-11e7-87e8-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldce4f54cc-64b2-11e7-87e8-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldce505e82-64b2-11e7-9076-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldce505e82-64b2-11e7-9076-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote><blockquote><p class="foldce515012-64b2-11e7-85c8-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldce515012-64b2-11e7-85c8-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldce528638-64b2-11e7-9e45-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldce528638-64b2-11e7-9e45-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote><blockquote><p class="foldce5381ac-64b2-11e7-8d81-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_X</strong>:</p><div class="unfoldce5381ac-64b2-11e7-8d81-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_X</strong></blockquote><blockquote><p class="foldce5473d2-64b2-11e7-b278-a820660f017d">Beginning of <strong>fix_A_new_gauge_optimize_Y</strong>:</p><div class="unfoldce5473d2-64b2-11e7-b278-a820660f017d"></div>End of <strong>fix_A_new_gauge_optimize_Y</strong></blockquote></div>End of <strong>while loop</strong></blockquote><blockquote><p class="foldce55d29c-64b2-11e7-8412-a820660f017d">Beginning of <strong>fix_A_new_gauge_update_to_gauge</strong>:</p><div class="unfoldce55d29c-64b2-11e7-8412-a820660f017d"></div>End of <strong>fix_A_new_gauge_update_to_gauge</strong></blockquote></div>End of <strong>fix_A_new_gauge</strong></blockquote>Put A_new,new_log_fact to return value<br><p class="param_use">return_pieces is true, put A_part_list,u,v,w,B,BUS,BSV,z into return value</p><p class="param_use">return_gauges & horz_refl true, then optimize_G_hv</p><blockquote><p class="foldce57578a-64b2-11e7-8609-a820660f017d">Beginning of <strong>optimize_G_hv</strong>:</p><div class="unfoldce57578a-64b2-11e7-8609-a820660f017d"><blockquote><p class="foldce57dfa4-64b2-11e7-8e9c-a820660f017d">Beginning of <strong>while loop under cost_change > 1e-11 and counter < 10000</strong>:</p><div class="unfoldce57dfa4-64b2-11e7-8e9c-a820660f017d"></div>End of <strong>while loop</strong></blockquote><log>After 3 iterations, error in optimize_G_hv is 2.098e-15.</log><br/><log><em>G_hv</em> has shape: [[5, 5], [5, 5]]</log><br/></div>End of <strong>optimize_G_hv</strong></blockquote><blockquote><p class="foldce5a9dfe-64b2-11e7-b41f-a820660f017d">Beginning of <strong>optimize_G_vh</strong>:</p><div class="unfoldce5a9dfe-64b2-11e7-b41f-a820660f017d"><blockquote><p class="foldce5ab35a-64b2-11e7-83cb-a820660f017d">Beginning of <strong>while loop under cost_change > 1e-11 and counter < 10000</strong>:</p><div class="unfoldce5ab35a-64b2-11e7-83cb-a820660f017d"></div>End of <strong>while loop</strong></blockquote><log>After 3 iterations, error in optimize_G_vh is 2.752e-15.</log><br/><log><em>G_vh</em> has shape: [[5, 5], [5, 5]]</log><br/></div>End of <strong>optimize_G_vh</strong></blockquote>put G_hh,G_hv,G_vh into return value</div>End of <strong>TNR_step</strong></blockquote></div>End of <strong>generate_next_tensor</strong></blockquote></div>End of <strong>generate_tensor</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_tensor</strong></blockquote></div>End of <strong>the for loop of iter_count</strong></blockquote>after all these RG steps, the norm of the final tensor A^{(s)} (self contraction) is equivalent to the partition function.<br/></div>End of <strong>generate_normalized_tensor</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_normalized_tensor</strong></blockquote>get the final tensor</div>End of <strong>get_T</strong></blockquote><blockquote><p class="foldce62f99a-64b2-11e7-910c-a820660f017d">Beginning of <strong>get_T_last</strong>:</p><div class="unfoldce62f99a-64b2-11e7-910c-a820660f017d"><blockquote><p class="foldce63008c-64b2-11e7-ae8b-a820660f017d">Beginning of <strong>get_defect</strong>:</p><div class="unfoldce63008c-64b2-11e7-ae8b-a820660f017d">Build the defect<br/></div>End of <strong>get_defect</strong></blockquote><blockquote><p class="foldce630d52-64b2-11e7-a47e-a820660f017d">Beginning of <strong>get_defect</strong>:</p><div class="unfoldce630d52-64b2-11e7-a47e-a820660f017d">Build the defect<br/></div>End of <strong>get_defect</strong></blockquote></div>End of <strong>get_T_last</strong></blockquote></div>End of <strong>get_cft_data</strong></blockquote></div>End of <strong>load_cft_data</strong></blockquote><em>do_coarse_momenta</em> is true, get <em>res_coarse</em> from <strong>load_cft_data</strong><blockquote><p class="foldd69b5cc2-64b2-11e7-859b-a820660f017d">Beginning of <strong>load_cft_data</strong>:</p><div class="unfoldd69b5cc2-64b2-11e7-859b-a820660f017d"><blockquote><p class="foldd69b6cee-64b2-11e7-aff5-a820660f017d">Beginning of <strong>get_cft_data</strong>:</p><div class="unfoldd69b6cee-64b2-11e7-aff5-a820660f017d"><blockquote><p class="foldd69b70e2-64b2-11e7-82e7-a820660f017d">Beginning of <strong>get_T</strong>:</p><div class="unfoldd69b70e2-64b2-11e7-82e7-a820660f017d"><blockquote><p class="foldd69b746e-64b2-11e7-9c4c-a820660f017d">Beginning of <strong>get_normalized_tensor</strong>:</p><div class="unfoldd69b746e-64b2-11e7-9c4c-a820660f017d"><blockquote><p class="foldd69b77d4-64b2-11e7-9523-a820660f017d">Beginning of <strong>get_general</strong>:</p><div class="unfoldd69b77d4-64b2-11e7-9523-a820660f017d"> A general getter function that either gets the asked-for data from a file or generates it with the given generator function.  <blockquote><p class="foldd69b7bf8-64b2-11e7-bc76-a820660f017d">Beginning of <strong>get_id_pars_and_set_default_pars</strong>:</p><div class="unfoldd69b7bf8-64b2-11e7-bc76-a820660f017d"></div>End of <strong>get_id_pars_and_set_default_pars</strong></blockquote></div>End of <strong>get_general</strong></blockquote></div>End of <strong>get_normalized_tensor</strong></blockquote>get the final tensorBuild the coarse-grained transfer matrix.<br/></div>End of <strong>get_T</strong></blockquote><blockquote><p class="foldd69ed3c0-64b2-11e7-ba2c-a820660f017d">Beginning of <strong>get_T_last</strong>:</p><div class="unfoldd69ed3c0-64b2-11e7-ba2c-a820660f017d"><blockquote><p class="foldd69edbae-64b2-11e7-bb41-a820660f017d">Beginning of <strong>get_defect</strong>:</p><div class="unfoldd69edbae-64b2-11e7-bb41-a820660f017d">Build the defect<br/></div>End of <strong>get_defect</strong></blockquote><blockquote><p class="foldd69ee6d0-64b2-11e7-a908-a820660f017d">Beginning of <strong>get_defect</strong>:</p><div class="unfoldd69ee6d0-64b2-11e7-a908-a820660f017d">Build the defect<br/></div>End of <strong>get_defect</strong></blockquote></div>End of <strong>get_T_last</strong></blockquote></div>End of <strong>get_cft_data</strong></blockquote></div>End of <strong>load_cft_data</strong></blockquote>combine <em>res_fine</em> and <em>res_coarse</em><br/><blockquote><p class="foldde5616d2-64b2-11e7-b249-a820660f017d">Beginning of <strong>combine_coarse_momenta</strong>:</p><div class="unfoldde5616d2-64b2-11e7-b249-a820660f017d"><blockquote><p class="foldde562152-64b2-11e7-b591-a820660f017d">Beginning of <strong>combine_momenta_nd</strong>:</p><div class="unfoldde562152-64b2-11e7-b591-a820660f017d"></div>End of <strong>combine_momenta_nd</strong></blockquote><blockquote><p class="foldde56a46e-64b2-11e7-ba20-a820660f017d">Beginning of <strong>combine_momenta_nd</strong>:</p><div class="unfoldde56a46e-64b2-11e7-ba20-a820660f017d"></div>End of <strong>combine_momenta_nd</strong></blockquote></div>End of <strong>combine_coarse_momenta</strong></blockquote>
</body>
</html>